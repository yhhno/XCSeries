wcf,rabbitmq,asp.net core 分布式视频，鬼谷子，麻宁这么好的东西，我怎么能忍受它放在那里睡大觉呢？ 不赶快吸收吸收，就算装装逼也好呀，是不是？

情绪上怎么样? 小事情，搞的定，一步一步来，不要有过多的任务压在心头，与完事开头难的矛盾， 退缩是不存在额，没有在怕的。=》  主动的话，这些问题就可能不存在，反而有其他更好地东西出现
我是来学学习能力的，学习方法论的，不仅仅是知识？ 不是学完就万事大吉了，=》本质
这个点没有评价好坏，未来的预期也没有评价好坏？
每个东西，都要深挖，不能只是了解它的作用，
每个新东西，旧东西， 其实都不难，调整好状态，跨出第一步，步步踏实，有啥难的，一多半都是自己吓自己。
既然心理作用这么大，我们可以怎么做呢？  之前用代入感，现在用成功者，也就是未来者（儿子清华，女儿北大）， =》积极主动
来句革命性的，这些东西真的有那么重要的吗？遇到它我不想学，产生退缩，我的一切都完了吗？ 当然不是的，我当然不是整天要面对不是这些事情，这些都是实现方式之一，人需要有哲学的角度，出一套指导思想，把一切都简略的画出来，然后去填空，而目前呢，只是在做填空的那一步，就像一个没有思想的人，那就是一个不知道为什么这么做的人在做事情，此时积极的发挥不出来，消极的全部放大，导致进展不下去。 
我们是思考抽象的高层次东西，怎么可以困在低层次的范围内呢？ 对不对？

必须要有整体上的认识，才可以去理解其中的概念，名词，底层的流程，抽象的流程，抽象的概念 大局观
各个点的知识知道了，但流程是什么呢？ 如何联系在一起呢？逻辑呢？  如何才算是理解透彻？概念的透彻，流程的透彻
什么是理解透彻呢？ 就是画一张图来概括，一定要学会这种方式， 知识点都串起来了，形象生动。记忆深刻  
##note###重大问题，基础知识不系统，不全面，有缺失，而且还不清晰牢固

之前总结，反思了很多东西，为什么效果平平呢？ 很大可能是激情没有涉及，（我一定杀20个人呢，）=>起势的东西没有。=》有了起势的结果是什么？=》遇到新东西一定搞明白，事情一定要完成，还有呢？
我就是要知道，既然是学习知识，首先先学到知识，然后在学到学习方法，如何实现呢？
感觉越学越简单，越容易，他妈的就是很简单嘛。
我相信只要我持续的思考，学习，我一定能掌握一套东西，然后学任何的东西都得心应手，都透彻，然后都应用的很好《=《精神层面最重要，不然就没有行动上的启动了，更别说方法的改进了和知识点的累积了》=>有一个方针，或者标准 如成才四标准和人际关系三种关系

 解决IT企业的信息孤岛问题。=》根本就没理解这句话的含义，，不够聪明。不够，缺点啥呢 另外，我们往往仅仅着眼于运用，更进一步是实现，但是都不是从0开始，演变也不清楚，当然更别谈什么导致了演变，环境的变化，（这是基本情况的梳理） 更别谈了，种种的归类，总结，对比（这是提炼出理论，抽象的东西）

 他学习得到东西和我学习得到的东西，为啥不一样？ 是由什么造成的呢？ 我也来对比下，（当然分自学和别人教授两种情况了）
问题的出现，都是能力的欠缺或者是不足造成的额， 此时的重点是补全能力，而不是关注表面的东西，======》》》》总结能力，必须总结，这是最终的关键地方
如果我没有了学习视频，自我学习一个技术，一个领域咋办呢？

问题7：谁有什么？ 一定要搞清楚，不能乱套用，都不清晰，当然稀里糊涂的，一定要界定清楚，说明学习时方式有问题，或者总结时有问题=》引申个大问题，你遇到的各种问题是因为你不具备某种能力，如果你具备了能力，这就不是问题，而是做事的步骤而已，它就不会拦着你，此时就不知道怎么办？心态也变得不好，（为什么有了问题就心态不好呢，长久的不能解决问题造成的），出现的次数多了，当你再遇到问题时，就是一个扭曲的心态了， 扩散到一个的方方面面，那这个人就出了问题， 就在你出了问题后，你也不知道该怎么做？ 去纠正也不知道怎么做？只能头疼医头，脚疼医脚，一个问题接着一个问题，貌似解决了问题，但是心态一点都没有改变，更有可能因为问题的不断出现，导致心态越来越差
问题2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉
问题10：很多情况就是我们对整个流程不清楚的情况下，去看概念，去应用，这样是不正确的



能力的总结
1.轻松的的心态，把所有的经历都专注在你要做的事情上，其他的任何东西都不要，本身要搞清楚，搞透彻，(关键是找准主方向)，然后延伸，发散，优化，总结等（满足于当前，没有更进一步的思考。）=》发散与集中，战略上发散，战术上集中
2.一个大的工具如wcf，一个小的方面，如wcf中behavior，都需要了解知识点，概念，运作机制，然后再一步一步的走下去，这样才算是理解透彻，甚至还包括修改参数带来的影响。=》这是学习知识的问题
3.找准主方向，一切都会迎刃而解的，关键如何找到主方向呢？ =》主方向是脉络清晰的升级，更进一步。
4.要开心快乐。



问题1：前几节课沉浸着学习服务行为，很容易，就忘了端点行为，甚至就忘了分类这件事的存在，潜意识只认为服务行为的存在，这样不会形成系统的知识的，
问题1.1 学东西，要在一个大的框架，大的流程的背景下去进行，
问题2:新概念，搞清楚，兴奋起来  画图  那端点行为到底是什么呢？ 方案都是为了解决问题的，
问题3：之间就是调用就完事了，其他的完全不用关心，你看看，没有大的框架，大的流程是啥结果。  如果没有理解这些东西，让我来做一个服务降级，在做呢，都不知道如何入手，给你案例，也看不明白呢。
问题4： 如何理解用它来监控这个endpoint behavior，就是有时会出现一些新名字，新概念不理解，它是干嘛的
问题3：Dispatch   DispatchRuntime DispatchMessageInspector叫消息检查器，
问题5：如何实现一分钟内阈值判断呢？  听到就不知道该怎么办？ 猜想下  不要怕


开始本节课前，应该思考这些东西 0.积极的心态 1,这节课讲的是什么，大概概况，解决的问题，2。新知识还是旧知识 3.旧的话自己的本身的认识是什么？用到饿了那些什么样的基础知识 4.新知识的话，该怎么办？5.根据用途猜想下它的实现 6.
结束本节课后，应该思考这些东西 1.学到的知识是什么？心中是否清晰？2.自己独立思考下 3.和自己预想的有什么不一样？ 4.有什么方法或者思维或者见识可以借鉴 5.总结下

问题1：前几节课沉浸着学习服务行为，很容易，就忘了端点行为，甚至就忘了分类这件事的存在，潜意识只认为服务行为的存在，这样不会形成系统的知识的，
问题1.1 学东西，要在一个大的框架，大的流程的背景下去进行，
大家好本节课，在来和大家说下端点行为， 前面两节课已经完整的和大家讲述了服务行为， 对吧
那么我们来开始讲端点行为，
他叫做endpoint behavior
问题2:新概念，搞清楚，兴奋起来  画图  那端点行为到底是什么呢？ 方案都是为了解决问题的，
那么端点行为大概是一个什么样的概念呢？
我们在讲之前，还是先画一张图，给大家来演示下，
既然端点行为，他出来，肯定是能解决某一类问题的， 对不对
就想前两节课，给大家说的服务行为，也是一样的  大家也知道它是用来干嘛的，对不对，
我们有一个service 有一个client，中间是通过transport进行传输的，对不对， 那么这个传输的话，它是一个流程，对不对 那么这个流程的话呢， 我们可以想一想， endpoint behavior 既然它可以动态的改变这个wcf的运行时，那么我们是不是可以 这么做呢？ 我们在画一个client 一个service 在这两者之间，我们能不能插一些endpoint behavior，也就是什么意思呢？ 也就是说我 client端所有的消息，先经过我这个插入的endpointbehavior ，然后通过我这个endpoint behavior转给你这个service，，
那这个的话呢， 有一点像 我们asp.net mvc的管道 也是著名的一个aop编程，
在我client端和service端之间插上一个endpoint behavior ，那么插进去之后， 我就可以改你这个message消息了，对不对， 也就是动态的篡改你的message，当然篡改是可以的，不篡改也是可以的，不管你窜不篡改，我都可以拿到你这个message ，做一些我们认为的一些操作，
比如说，我们可以举个例子，
我们的service其实都想做一个 接口的实时统计， service方法的实时调用量统计，这是不是可以，
比如我下面有个ModifyStudent函数，这个ModifyStudent函数，它的totalcount，
第二个getstudent 我也要看下它的totalcount，
第三个AddStudent  我也要看下它的totalcount，
这就相当于一个监控大屏 有了这个监控大屏，我就可以实时的去看
问题3：之间就是调用就完事了，其他的完全不用关心，你看看，没有大的框架，大的流程是啥结果。  如果没有理解这些东西，让我来做一个服务降级，在做呢，都不知道如何入手，给你案例，也看不明白呢。 
这样的话，就方便我们这些运维 可以实时的去查看 服务的运行状态 ，当然的话，基于这个数据 我们还可以做什么？还可以做服务的降级， 什么意思呢？  比如说你一分钟之内某些函数调用量太高， 我可以直接回绝此操作， 对吧， 这个叫做服务的降级，  我们可以用一分钟的阈值来做，还可以用这个错误量也可以做服务的降级 对吧，
ok，这个就是我刚才给大家介绍的endpoint behavior的一个好处，确实的话，它能够实时抓得到message

问题4： 如何理解用它来监控这个endpoint behavior，就是有时会出现一些新名字，新概念不理解，它是干嘛的
消息的检查，我们是通过什么呢，我们是通过这个地方 有一个messageInspector 用它来监控这个endpoint behavior，能做很多事情，  比如说，我们后面的课程给大家讲到的protobuf 它是google的一个序列化器， 后面给大家讲，利用它对内容的压缩，，避免之前的xml infoset这种模式  也就是替换一种序列化方式，

ok，接下来，我就用代码给大家演示下，

服务接口
 [ServiceContract]
    public interface IStudent
    {
        [OperationContract]
        void AddStudent();

        [OperationContract]
        void RemoveStudent();

        [OperationContract]
        void ModifyStudent();

        [OperationContract]
        void GetStudent();
    }
我们有四个方法。
我们是实现下，
public class StudentService : IStudent
    {
        public void AddStudent()
        {
            Console.WriteLine("AddStudent 成功");
        }

        public void GetStudent()
        {
            Console.WriteLine("GetStudent 成功");
        }

        public void ModifyStudent()
        {
            Console.WriteLine("ModifyStudent 成功");
        }

        public void RemoveStudent()
        {
            Console.WriteLine("RemoveStudent 成功");
        }
    }
接下来，我们新建个类库
因为是端点行为，所以我们要定义一个myendpointbehavior类，并实现IEndpointBehavior接口，  我们要引用下system.servicemodel
 public class MyEndpointBehavior : IEndpointBehavior
    {
        public void AddBindingParameters(ServiceEndpoint endpoint, BindingParameterCollection bindingParameters)
        {
        }

        public void ApplyClientBehavior(ServiceEndpoint endpoint, ClientRuntime clientRuntime)
        {
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="endpoint"></param>
        /// <param name="endpointDispatcher"></param>
        public void ApplyDispatchBehavior(ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)
        {
		//添加一个自定义的消息检查器，
            endpointDispatcher.DispatchRuntime.MessageInspectors.Add(new MyDispatchMessageInspector());
        }

        public void Validate(ServiceEndpoint endpoint)
        {
        }
    }



这个ApplyDispatchBehavior函数是你client到service端必经的一个函数， 这个大家一定要知道，在这个函数中，我添加一个自定义的消息检查器，

问题3：Dispatch   DispatchRuntime DispatchMessageInspector叫消息检查器，  不要怕
endpointDispatcher.DispatchRuntime.MessageInspectors.Add(new MyDispatchMessageInspector()); 添加一个自定义的消息检查器，
调度的运行时 DispatchRuntime

新建个MyDispatchMessageInspector类 实现IDispatchMessageInspector接口
public class MyDispatchMessageInspector : IDispatchMessageInspector
    {
        //这个地方，大家可以用redis来实现。。。
        public static Dictionary<string, int> totalDic = new Dictionary<string, int>();

        /// <summary>
        /// 收到之后
        /// </summary>
        /// <param name="request"></param>
        /// <param name="channel"></param>
        /// <param name="instanceContext"></param>
        /// <returns></returns>
        public object AfterReceiveRequest(ref Message request, IClientChannel channel, InstanceContext instanceContext)
        {
            var action = request.Headers.GetHeader<string>("Action", "http://schemas.microsoft.com/ws/2005/05/addressing/none");

            if (!totalDic.ContainsKey(action))
            {
                totalDic[action] = 0;
            }

            totalDic[action]++;

            Console.WriteLine("当前时间:{0} action={1}, 调用次数为:{2}", DateTime.Now, action, totalDic[action]);

            return request;
        }

        /// <summary>
        /// 回复之前
        /// </summary>
        /// <param name="reply"></param>
        /// <param name="correlationState"></param>
        public void BeforeSendReply(ref Message reply, object correlationState)
        {

        }
    }

	AfterReceiveRequest收到消息之后，
	ApplyClientBehavior再回复之前

所以说我们可以在AfterReceiveRequest  函数中，return之前做任何想要的操作。 比如统计
刚才已经讲到，我们可以直接受到client传来的message，既ref Message request，
那我们去看怎么去获取它的参数呢？
首先的话，我们先运行下，看看它的message到底是什么样的，然后我们从这个message中把它的这个to和action都抓下来， 因为我要做一个接口的实时统计嘛，
编译启动service端
client端添加服务引用个，
ok，接下来添加调用代码
 static void Main(string[] args)
        {
            StudentClient client = new ServiceReference1.StudentClient();

            Action[] actions = new Action[4] {
                client.AddStudent,
                client.ModifyStudent,
                client.RemoveStudent,
                client.GetStudent };

            while (true)
            {
                var index = new Random().Next(0, 4);

                actions[index]();

                Console.WriteLine("当前调用成功。。。。{0}", DateTime.Now);

                System.Threading.Thread.Sleep(2000);
            }
        }
client端，到底调那个函数呢，有4个呢，
用泛型list List<action> 或者Action数组 接受下，因为我要模拟随机的操作，
产生一个随机数，随机一个index出来，
启动client端，
client端显示当前调用成功，
对应的service显示 调用函数执行成功。
启动fiddler
或者在service端下个断点，vs用管理员模式启动
service端添加自定义的endpoint behavior
 static void Main(string[] args)
        {
            ServiceHost host = new ServiceHost(typeof(StudentService));

            host.Description.Endpoints[0].EndpointBehaviors.Add(new MyEndpointBehavior());

            host.Open();

            Console.WriteLine("wcf启动成功！");
            Console.Read();
        }
调试，运行到断点处，获取message信息
{<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
  <s:Header>
    <To s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none">http://192.168.23.1:8732/HomeService</To>
    <Action s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none">http://tempuri.org/IStudent/AddStudent</Action>
  </s:Header>
  <s:Body>
    <AddStudent xmlns="http://tempuri.org/" />
  </s:Body>
</s:Envelope>}
可以获取to  action


 //这个地方，大家可以用redis来实现。。。
        public static Dictionary<string, int> totalDic = new Dictionary<string, int>();

        /// <summary>
        /// 收到之后
        /// </summary>
        /// <param name="request"></param>
        /// <param name="channel"></param>
        /// <param name="instanceContext"></param>
        /// <returns></returns>
        public object AfterReceiveRequest(ref Message request, IClientChannel channel, InstanceContext instanceContext)
        {
            var action = request.Headers.GetHeader<string>("Action", "http://schemas.microsoft.com/ws/2005/05/addressing/none");

            if (!totalDic.ContainsKey(action))
            {
                totalDic[action] = 0;
            }

            totalDic[action]++;

            Console.WriteLine("当前时间:{0} action={1}, 调用次数为:{2}", DateTime.Now, action, totalDic[action]);

            return request;
        }

问题5：如何实现一分钟内阈值判断呢？  听到就不知道该怎么办？ 猜想下  不要怕
这样大家就可以实时看下监控大屏额，
这时候我们拿到这些统计数据之后，我们就可以做各种操作了， 比如说服务的降级， 如果说你某一分钟内调用的次数太大， 对不对，因为你每次调用时的时间 都是由的，
当然的话，还可以获取到当前调用的ip ，如果你这个ip访问台频繁了，我还可以把把你你这个ip禁掉。 或者说加到黑名单中去，不让你这个ip访问wcf ，具体wcf如何获取到client的ip 大家去搜下，

ok这就是本节课给大家讲的内容，后面还有两节课讲关于endpoint 的  
一个是用户名密码登录 也就是wcf安全 可以用这种消息拦截
一个是protobuf 序列化机制




一：端点行为 EndpointBehavior

@有一c像asp.net mvc 的管道。。。 【AOP】 动态篡改message。。。

二：service方法的实时调用量统计 【监控大屏】

1. ModifyStudent  TotalCount

2. GetStudent     TotalCount

3. AddStudent    TotalCount

服务降级  【一分钟之内（错误量）（IP） 某些函数调用量太大，我可以直接回绝此操作。。。】

protoBuf 【google 一个序列化工具】 xml infoset 【DataContract】

三：演示

{<s:Envelope xmlns:s="http://schemas.xmlsoap.org/soap/envelope/">
  <s:Header>
    <To s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none">http://192.168.23.1:8732/HomeService</To>
    <Action s:mustUnderstand="1" xmlns="http://schemas.microsoft.com/ws/2005/05/addressing/none">http://tempuri.org/IStudent/AddStudent</Action>
  </s:Header>
  <s:Body>
    <AddStudent xmlns="http://tempuri.org/" />
  </s:Body>
</s:Envelope>}

