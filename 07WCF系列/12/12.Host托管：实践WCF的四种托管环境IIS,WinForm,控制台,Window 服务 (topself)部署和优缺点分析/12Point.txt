情绪上怎么样? 小事情，搞的定，一步一步来，不要有过多的任务压在心头，与完事开头难的矛盾， 退缩是不存在额，没有在怕的。=》  主动的话，这些问题就可能不存在，反而有其他更好地东西出现
我是来学学习能力的，学习方法论的，不仅仅是知识？ 不是学完就万事大吉了，=》本质
这个点没有评价好坏，未来的预期也没有评价好坏？
每个东西，都要深挖，不能只是了解它的作用，
每个新东西，旧东西， 其实都不难，调整好状态，跨出第一步，步步踏实，有啥难的，一多半都是自己吓自己。
既然心理作用这么大，我们可以怎么做呢？  之前用代入感，现在用成功者，也就是未来者（儿子清华，女儿北大）， =》积极主动
来句革命性的，这些东西真的有那么重要的吗？遇到它我不想学，产生退缩，我的一切都完了吗？ 当然不是的，我当然不是整天要面对不是这些事情，这些都是实现方式之一，人需要有哲学的角度，出一套指导思想，把一切都简略的画出来，然后去填空，而目前呢，只是在做填空的那一步，就像一个没有思想的人，那就是一个不知道为什么这么做的人在做事情，此时积极的发挥不出来，消极的全部放大，导致进展不下去。 
我们是思考抽象的高层次东西，怎么可以困在低层次的范围内呢？ 对不对？

必须要有整体上的认识，才可以去理解其中的概念，名词，底层的流程，抽象的流程，抽象的概念 大局观
各个点的知识知道了，但流程是什么呢？ 如何联系在一起呢？逻辑呢？  如何才算是理解透彻？概念的透彻，流程的透彻
什么是理解透彻呢？ 就是画一张图来概括，一定要学会这种方式， 知识点都串起来了，形象生动。记忆深刻
##note###重大问题，基础知识不系统，不全面，有缺失，而且还不清晰牢固

之前总结，反思了很多东西，为什么效果平平呢？ 很大可能是激情没有涉及，（我一定杀20个人呢，）=>起势的东西没有。
我就是要知道，既然是学习知识，首先先学到知识，然后在学到学习方法，如何实现呢？
感觉越学越简单，越容易，他妈的就是很简单嘛。
我相信只要我持续的思考，学习，我一定能掌握一套东西，然后学任何的东西都得心应手，都透彻，然后都应用的很好《=《精神层面最重要，不然就没有行动上的启动了，更别说方法的改进了和知识点的累积了》=>有一个方针，或者标准 如成才四标准和人际关系三种关系

 解决IT企业的信息孤岛问题。=》根本就没理解这句话的含义，，不够聪明。不够，缺点啥呢 另外，我们往往仅仅着眼于运用，更进一步是实现，但是都不是从0开始，演变也不清楚，当然更别谈什么导致了演变，环境的变化，（这是基本情况的梳理） 更别谈了，种种的归类，总结，对比（这是提炼出理论，抽象的东西）

 他学习得到东西和我学习得到的东西，为啥不一样？ 是由什么造成的呢？ 我也来对比下，（当然分自学和别人教授两种情况了）
问题的出现，都是能力的欠缺或者是不足造成的额， 此时的重点是补全能力，而不是关注表面的东西，======》》》》总结能力，必须总结，这是最终的关键地方
如果我没有了学习视频，自我学习一个技术，一个领域咋办呢？

问题7：谁有什么？ 一定要搞清楚，不能乱套用，都不清晰，当然稀里糊涂的，一定要界定清楚，说明学习时方式有问题，或者总结时有问题=》引申个大问题，你遇到的各种问题是因为你不具备某种能力，如果你具备了能力，这就不是问题，而是做事的步骤而已，它就不会拦着你，此时就不知道怎么办？心态也变得不好，（为什么有了问题就心态不好呢，长久的不能解决问题造成的），出现的次数多了，当你再遇到问题时，就是一个扭曲的心态了， 扩散到一个的方方面面，那这个人就出了问题， 就在你出了问题后，你也不知道该怎么做？ 去纠正也不知道怎么做？只能头疼医头，脚疼医脚，一个问题接着一个问题，貌似解决了问题，但是心态一点都没有改变，更有可能因为问题的不断出现，导致心态越来越差
问题2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉

能力的总结
1.轻松的的心态，把所有的经历都专注在你要做的事情上，其他的任何东西都不要，本身要搞清楚，搞透彻，然后延伸，发散，优化，总结等（满足于当前，没有更进一步的思考。）=》发散与集中，战略上发散，战术上集中
2.


开始本节课前，应该思考这些东西 0.积极的心态 1,这节课讲的是什么，大概概况，解决的问题，2。新知识还是旧知识 3.旧的话自己的本身的认识是什么？用到饿了那些什么样的基础知识 4.新知识的话，该怎么办？5.根据用途猜想下它的实现 6.
结束本节课后，应该思考这些东西 1.学到的知识是什么？心中是否清晰？2.自己独立思考下 3.和自己预想的有什么不一样？ 4.有什么方法或者思维或者见识可以借鉴 5.总结下

问题1：我们优先使用谁呢？这是个好问题，有一个标准，然后分分类，
问题2：此处可能存在一个问题，这个东西是个封装后的东西，算是一个抽象的东西，如果没有底层的知识，硬看这个，会看不明白，不理解的，然后，一个有一个不理解，然后又不深究，去了解，带着这个不理解，进行下去，越来越蒙，到最后，sb了，因为你做的每一步都不知道是什么意思？ 那你还做个啥呢？ 更别说应用了。
问题2:以及对console作为宿主程序见怪不怪了，甚至把它当做宿主的全部了,这暴露了一个问题，学习的时候，不深刻， 不是一个聪明的行为，
问题2.2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题2.3 既然出现了2的问题，如何改进了，如果还没有深刻的透彻的认识，就从外界找打深刻的，透彻的认识。
问题2 ServiceHost是干嘛的？  正常的windows 服务是如何安装的， topself代替了哪些工作？ 为什么./wcfservice.exe 可以有install help 呢  其他的redis安装成Windows服务 有什么异同呢？

问题3：自动化部署是什么？C#和powershell交互有是什么呢？ topself是如何出现的呢? 有什么借鉴意义？如看到一个复杂的东西，想着如何简化，
问题4:其实进行到这里，心里蒙蒙的，首先用topself代码，不明白什么意思，然后exe install 也不明白， 也不明白交互，自动化部署是什么概念？
问题5：就算是遇到这么多的问题，情绪也不能低落，哇，又可以进步很多了，又变得优秀了， 情绪的问题第一重要，
问题6:为什么没想到禁用？一开始就是调试，部署了之后，也没遇到误操作，就算有误操作，重启下就完成了，不能想其他方案，就算想其他方案，能不能想到禁用x呢，就算想到了，怎么禁用知道吗？win32知识有没有储备呀？或者跳出这个console方案，采用其他的方案呢？
问题7：禁用只是一种方案的实现，不具有通用性，他当然不是全部咯。
问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题8.1，适配 兼容
问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉
问题10，可视化，定制，更好的交互



本节课的终极目标是，自动化部署
大家好，本节课就给大家讲下服务托管的概念，
ok，回到第一节课，我给大家画的一张图，这张图上，有一块叫做服务托管，既宿主， 宿主的话， 我们又iis，windows services，winform，wpf，还有一个经常用到的console，
问题1：我们优先使用谁呢？这是个好问题，有一个标准，然后分分类，
ok，既然有这么多的服务托管方式，我们优先使用谁呢， o
ok，这里我就做了优先级的排列，那么可想而知，我们最容易，也就是 优先级最高的部署，也就是应用最广的 肯定是windows服务，对不对，ok，用windows服务做宿主，怎么去做呢？其实微软 它自己有一个服务模板，在哪里呢？ windows服务模板其实还是很麻烦的， 比如说我们随便点一个新建项  选中windows服务 这个是创建windows服务的模板， 比较麻烦，微软在这方面也是不给力，没有一键安装的这种框架，可以一键安装windows服务， ok，这时候有一个topself 可以方便做服务部署， 那么这是一个第三方的插件， 等一下，我们在给大家讲， 什么叫一键部署呢，就是一步简单的步骤，代替多步复杂的步骤，
然后，第二多的是console。其实我们在之前的课程中，已经给大家讲到了，用console来进行部署，但是的话呢，实际部署中，我看到很多人把关闭按钮禁用了，什么是关闭按钮，那比如说，我们随便启动一个wcf服务，我们看到console窗口右上角有一个×，对不对， 我们可以通过win32函数把这个×给禁掉，console这个也是比较方便的，而且的话，容易调试，禁用关闭按钮，防止误操作， topself是生产环境第一选择，
然后呢，是iis，iis它是第三个优先级，iis的话 它受制于这个w3wp进程，所以说的话呢，部署在iis上面，有是有，但是呢，很少，它是以svc后缀名存在的，这个话，大家根据自己需要把，但是我是不特别建议，放到iis上，要么用windows服务，要么console。console还可以作为早期的生产部署，
然后是winform，winform和wpf 可以放到一块来讲， 他们两个是差不多的东西，他们有一个可视化的界面，交互起来比较方便， 对不对，，可能在某些时候，比console好一点，console你只能看到一些输出，你交互的话，比较麻烦，对不对，有些人，可能会做一些定制化的，就可以放到winform上去， 这个就根据大家的实际需要了，

ok，接下来 我就要给大家讲下，如何通过这个windows服务，进行承载，部署， 刚才也讲到了，我们去找下topself，它的官网是 www.topself-project.com,然后呢，怎么去操作呢， 这个地方有个文档，文档有 installing topself， 大家可以根文档实际操作下
首先的话，我们要安装下topself 现在我是要把这个wcfservice项目做成windows服务，大家看清楚了，在这个wcfservice项目，安装topsell的nuget包，
安装之后，我们该怎么做呢?其实还是比较简单的，ok，我们顺着文档继续往下找， 
找到showmecode 也就是quickstart  这有它的一个案例代码，总共 分成9步

问题2：此处可能存在一个问题，这个东西是个封装后的东西，算是一个抽象的东西，如果没有底层的知识，硬看这个，会看不明白，不理解的，然后，一个有一个不理解，然后又不深究，去了解，带着这个不理解，进行下去，越来越蒙，到最后，sb了，因为你做的每一步都不知道是什么意思？ 那你还做个啥呢？ 更别说应用了。
此处什么意思呢，就是用topself简化了Windows服务程序，而Windows服务程序是作为wcf的宿主的，
 HostFactory.Run(x =>                                 //1
            {
                x.Service<ServiceHost>(s =>                        //2  泛型类型
                {
                    s.ConstructUsing(name => new ServiceHost(typeof(HomeService)));     //3  实例
                    s.WhenStarted(tc => tc.Open());              //4
                    s.WhenStopped(tc => tc.Close());               //5
                });

                x.RunAsLocalSystem();                            //6 LocalSystem账户的形式在后台自动运行  也就是做在windows服务作为宿主程序的步骤，可以通过一个函数，在这里替代，

                x.SetDescription("这是我的第一个wcf服务");        //7  描述
                x.SetDisplayName("HomeService");                       //8
                x.SetServiceName("HomeService");                       //9  C#代码和powshell 交互  
            });

运行一下，  就是点击exe程序，
接下来就是作为windows服务，如何安装
查看官方文档
MyService.exe install -username:DOMAINServiceAccount -password:itsASecret -servicename:AwesomeService Cautostart 正常的window服务程序在powershell中的安装的步骤，但是用了topself后，不用新建Windows服务程序，直接用console程序，添加服务类库，添加topself代码，然后不用在powshell中用很多的参数，直接一个install，或者加上其他参数如用户名密码之类的 完成自动化部署，  
此时调出powershell  powershell有点像xshell，你可以认为是xshell。  xshell我们经常用来，远程连接centos liunx类型的系统
ok，首先我们要cd 到 项目目录
进入目录后，要做什么呢？
.\WcfService.exe help 查看可以执行的命令，
查到instal命令，然后执行
.\WcfService.exe install
service 安装好之后，
启动服务
查看wsdl  此时可以看到服务启动成功了，
ok，接下来就有一个问题呢  我能不能安装好了，就启动，	 安装好就启动，这就是自动化部署，不需要手工启动个
当然是可以的额，我们先看下如何把这个服务卸载掉，
.\WcfService.exe uninstall
然后
.\WcfService.exe install start  我们就不要人工的去开启了，
这个也是我们生产中，使用特别多的额，因为什么？ 因为 我们可以用C#代码和powshell进行代码交互。。。。  这时候我们就可以做到一个什么样的部署呢，我们就可以做到自动化部署，对不对，
这也是我们在生产环境和大家推崇的，早期你可以使用console这种，观察下，方便我们快速的实时更新， 如果说你这个service多了，wcf有10台，20台， 那你这个时候应该用c#代码和powershell进行交互，实时的去部署，因为这样你部署起来很方便的， 我们只要找到这个exe，然后呢，install start就ok了，这个服务就自动部署了。 对吧 安装windows服务是在powershell中进行的，c#和powshell交互，是指什么？把在powshell中的部分工作，放到C#中完成？这样理解对不对，

问题2:以及对console作为宿主程序见怪不怪了，甚至把它当做宿主的全部了,这暴露了一个问题，学习的时候，不深刻， 不是一个聪明的行为，
问题2.2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题2.3 既然出现了2的问题，如何改进了，如果还没有深刻的透彻的认识，就从外界找打深刻的，透彻的认识。
问题2 ServiceHost是干嘛的？  正常的windows 服务是如何安装的， topself代替了哪些工作？ 为什么./wcfservice.exe 可以有install help 呢  其他的redis安装成Windows服务 有什么异同呢？

问题3：自动化部署是什么？C#和powershell交互有是什么呢？ topself是如何出现的呢? 有什么借鉴意义？如看到一个复杂的东西，想着如何简化，
MyService.exe install -username:DOMAINServiceAccount -password:itsASecret -servicename:AwesomeService Cautostart 
正常的window服务程序在powershell中的安装的步骤，但是用了topself后，不用新建Windows服务程序，直接用console程序，添加服务类库，添加topself代码，然后不用在powshell中用很多的参数，直接一个install，或者加上其他参数如用户名密码之类的 完成自动化部署，    
问题4:其实进行到这里，心里蒙蒙的，首先用topself代码，不明白什么意思，然后exe install 也不明白， 也不明白交互，自动化部署是什么概念？
问题5：就算是遇到这么多的问题，情绪也不能低落，哇，又可以进步很多了，又变得优秀了， 情绪的问题第一重要，


ok 我们接下来再说第二种吧，topself希望，大家课后好好了解下，按照课程实际操作下，
然后的话是console，console的话，我们用到了无数次，
我们经常是这么使用的，如果生产环境下，wcf个数在5个一下，使用console还是很方便的，对吧，

问题6:为什么没想到禁用？一开始就是调试，部署了之后，也没遇到误操作，就算有误操作，重启下就完成了，不能想其他方案，就算想其他方案，能不能想到禁用x呢，就算想到了，怎么禁用知道吗？win32知识有没有储备呀？或者跳出这个console方案，采用其他的方案呢？
ok，接下来就先启动下，我刚才也讲到了，这时候有些人会把x给禁用了，因为没禁用的话，有一个误操作的存在，一旦误操作的话，wcf就挂了，挂了的话，风险还是蛮大的， 所以说我找了一个win32的函数，把x给禁用了， 我们可以用这段代码来实下， 大家也可以在生产环境中，试下，防止程序员或者运营人员误操作。
        static void Main(string[] args)
        {
            //禁用关闭‘按钮’
            DisableCloseButton(Console.Title);

            ServiceHost host = new ServiceHost(typeof(HomeService));

            host.Open();

            Console.WriteLine("wcf启动成功！");
            Console.Read();
        }
问题7：禁用只是一种方案的实现，不具有通用性，他当然不是全部咯。
ok，我们编译下，启动下，看到x被禁用了， 禁掉的好友大家应该也知道了，关的话只能在任务栏 右键关闭，


接下来。我们来看下第三种，iis作为宿主，
新建一个新建项，去找到一个wcf的一个模板，可以部署在iis上，它是有后缀名的， 这个有点像  带有svc后缀名，有点像mvc网站，或者说像ashx一般处理文件，
ok，我们在新建项中找到wcf服务应用程序  新建
我们发现在此项目中，所有的服务都是有svc后缀名的，看到没，都是有这个后缀名的，然后我们可以看下它的webconfig

问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现它serviceHost没有
 <system.serviceModel>
    <behaviors>
      <serviceBehaviors>
        <behavior>
          <!-- 为避免泄漏元数据信息，请在部署前将以下值设置为 false -->
          <serviceMetadata httpGetEnabled="true" httpsGetEnabled="true"/>
          <!-- 要接收故障异常详细信息以进行调试，请将以下值设置为 true。在部署前设置为 false 以避免泄漏异常信息 -->
          <serviceDebug includeExceptionDetailInFaults="false"/>
        </behavior>
      </serviceBehaviors>
    </behaviors>
    <protocolMapping>
        <add binding="basicHttpsBinding" scheme="https"/>
    </protocolMapping>  
	问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题8.1，适配 兼容
    <serviceHostingEnvironment aspNetCompatibilityEnabled="true" multipleSiteBindingsEnabled="true"/>//asp.net的一个兼容适配，因为毕竟它是要部署在iis上，所以说wcf和iis有一个适配
  </system.serviceModel>



  问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉

  启动下， 有个目录，点击下Service1.svc，出现了类似之前wsdl的东西， 可以看得到，相当于部署到在哪里呢?  部署在iisexpress上，  对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，iisexpress是简易版的iis
  调试的时候，就相当于部署到了iis上去了。
  但是我们发现有个什么东西没有呢，我们们发现它serviceHost没有， 这个是这样的额，如果说你当时访问到这个svc的时候，它会自动创建这个宿主环境
  ok，我们可以先把他发布下  
  自定义配置 my
  选择 文件系统
  选择目录
  发布完成
  然后接下来
  我们就可以创建一个网站 mywcf
  物理路径 是刚才的发布地址
  ip地址，端口  应用程序域4.0
  启动，浏览
  出现一个文件目录，点击service1.svc 这个相当于我们在iis上进行部署了  还是非常方便的，是不是
  ok，这样，相当于我们在iis上也部署了wcf。

接下来，我们再说最后一个
问题10，可视化，定制，更好的交互
如果说你有一些定制的需求的话呢， 你可以使用wpf或者winform   
这也是我认为使用最少的一种
ok，我们可以简单来看下， 我们就以winform为例
winform和console本质上是一样的额，
新建一个winform程序，
然后把服务接口和实现拷贝过来， 引用system.servicemodel
然后把承载代码拷贝到，form_load事件中，
然后还有一个配置文件 也拷贝过来，  
修改命名空间
然后编译，用管理员模式启动exe
此时就启动成功了，浏览器输入服务地址，，很简单，对不对，


ok这就是本节课，给大家介绍的所有内容了，  主要的是，大家一定要熟悉前两种， 第一种是Windows服务，他适合大规模部署， console适合小规模的额，，iis就是可选择可不选择，


一：wcf服务托管

1. windowservice 【windows服务】 做宿主环境 【大模部署】
  
   topself 可以方便做服务部署 【生产环境第一选择】
   
   看到这些网址，竟然还存在一丝恐惧，
   http://topshelf-project.com/

   https://topshelf.readthedocs.io/en/latest/installation/install.html

   https://topshelf.readthedocs.io/en/latest/configuration/quickstart.html


   https://topshelf.readthedocs.io/en/latest/overview/commandline.html
《1》 code topshelf的代码

《2》 install

powshell => xshell  类比

.\WcfService.exe install

问题：安装好了能马上自启动吗？？？

.\WcfService.exe install start


MyService.exe install -username:DOMAINServiceAccount -password:itsASecret -servicename:AwesomeService Cautostart

我们可以用C#代码和powshell进行代码交互。。。。

        static void Main(string[] args)
        {
            HostFactory.Run(x =>                                 //1
            {
                x.Service<ServiceHost>(s =>                        //2
                {
                    s.ConstructUsing(name => new ServiceHost(typeof(HomeService)));     //3
                    s.WhenStarted(tc => tc.Open());              //4
                    s.WhenStopped(tc => tc.Close());               //5
                });

                x.RunAsLocalSystem();                            //6

                x.SetDescription("这是我的第一个wcf服务");        //7
                x.SetDisplayName("HomeService");                       //8
                x.SetServiceName("HomeService");                       //9
            });
        }

2. console  【禁用关闭】【小规模部署】

   容易调试，禁用关闭按钮，防止误操作 【早期的生产部署】

   如果生产环境下，wcf个数在5个一下，使用wcf的console还是很方便的。。。。

   
3. iis 【svc】

   w3wp进程

  有一点像mvc网站、 ashx一般处理文件。

  《1》 点击使用 “文件系统”的形式发布

  《2》配置iis。。【应用程序域】


4. winform / wpf
  
   可视化的一个界面 【交互起来比较方便】。

windows服务 > console > iis > winform/wpf



public class ConsoleBase
    {
        #region 禁用关闭按钮
        [DllImport("User32.dll", EntryPoint = "FindWindow")]
        static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", EntryPoint = "GetSystemMenu")]
        static extern IntPtr GetSystemMenu(IntPtr hWnd, IntPtr bRevert);

        [DllImport("user32.dll", EntryPoint = "RemoveMenu")]
        static extern IntPtr RemoveMenu(IntPtr hMenu, uint uPosition, uint uFlags);

        ///<summary>
        /// 禁用关闭按钮
        ///</summary>
        ///<param name="consoleName">控制台名字</param>
        public static void DisableCloseButton(string title)
        {
            //线程睡眠，确保closebtn中能够正常FindWindow，否则有时会Find失败。。
            System.Threading.Thread.Sleep(100);

            IntPtr windowHandle = FindWindow(null, title);
            IntPtr closeMenu = GetSystemMenu(windowHandle, IntPtr.Zero);
            uint SC_CLOSE = 0xF060;
            RemoveMenu(closeMenu, SC_CLOSE, 0x0);
        }

        public static bool IsExistsConsole(string title)
        {
            IntPtr windowHandle = FindWindow(null, title);
            if (windowHandle.Equals(IntPtr.Zero)) return false;

            return true;
        }
        #endregion
    }

