情绪上怎么样? 小事情，搞的定，一步一步来，不要有过多的任务压在心头，与完事开头难的矛盾， 退缩是不存在额，没有在怕的。=》  主动的话，这些问题就可能不存在，反而有其他更好地东西出现
我是来学学习能力的，学习方法论的，不仅仅是知识？ 不是学完就万事大吉了，=》本质
这个点没有评价好坏，未来的预期也没有评价好坏？
每个东西，都要深挖，不能只是了解它的作用，
每个新东西，旧东西， 其实都不难，调整好状态，跨出第一步，步步踏实，有啥难的，一多半都是自己吓自己。
既然心理作用这么大，我们可以怎么做呢？  之前用代入感，现在用成功者，也就是未来者（儿子清华，女儿北大）， =》积极主动
来句革命性的，这些东西真的有那么重要的吗？遇到它我不想学，产生退缩，我的一切都完了吗？ 当然不是的，我当然不是整天要面对不是这些事情，这些都是实现方式之一，人需要有哲学的角度，出一套指导思想，把一切都简略的画出来，然后去填空，而目前呢，只是在做填空的那一步，就像一个没有思想的人，那就是一个不知道为什么这么做的人在做事情，此时积极的发挥不出来，消极的全部放大，导致进展不下去。 
我们是思考抽象的高层次东西，怎么可以困在低层次的范围内呢？ 对不对？

必须要有整体上的认识，才可以去理解其中的概念，名词，底层的流程，抽象的流程，抽象的概念 大局观
各个点的知识知道了，但流程是什么呢？ 如何联系在一起呢？逻辑呢？  如何才算是理解透彻？概念的透彻，流程的透彻
什么是理解透彻呢？ 就是画一张图来概括，一定要学会这种方式， 知识点都串起来了，形象生动。记忆深刻  
##note###重大问题，基础知识不系统，不全面，有缺失，而且还不清晰牢固

之前总结，反思了很多东西，为什么效果平平呢？ 很大可能是激情没有涉及，（我一定杀20个人呢，）=>起势的东西没有。=》有了起势的结果是什么？=》遇到新东西一定搞明白，事情一定要完成，还有呢？
我就是要知道，既然是学习知识，首先先学到知识，然后在学到学习方法，如何实现呢？
感觉越学越简单，越容易，他妈的就是很简单嘛。
我相信只要我持续的思考，学习，我一定能掌握一套东西，然后学任何的东西都得心应手，都透彻，然后都应用的很好《=《精神层面最重要，不然就没有行动上的启动了，更别说方法的改进了和知识点的累积了》=>有一个方针，或者标准 如成才四标准和人际关系三种关系

 解决IT企业的信息孤岛问题。=》根本就没理解这句话的含义，，不够聪明。不够，缺点啥呢 另外，我们往往仅仅着眼于运用，更进一步是实现，但是都不是从0开始，演变也不清楚，当然更别谈什么导致了演变，环境的变化，（这是基本情况的梳理） 更别谈了，种种的归类，总结，对比（这是提炼出理论，抽象的东西）

 他学习得到东西和我学习得到的东西，为啥不一样？ 是由什么造成的呢？ 我也来对比下，（当然分自学和别人教授两种情况了）
问题的出现，都是能力的欠缺或者是不足造成的额， 此时的重点是补全能力，而不是关注表面的东西，======》》》》总结能力，必须总结，这是最终的关键地方
如果我没有了学习视频，自我学习一个技术，一个领域咋办呢？

问题7：谁有什么？ 一定要搞清楚，不能乱套用，都不清晰，当然稀里糊涂的，一定要界定清楚，说明学习时方式有问题，或者总结时有问题=》引申个大问题，你遇到的各种问题是因为你不具备某种能力，如果你具备了能力，这就不是问题，而是做事的步骤而已，它就不会拦着你，此时就不知道怎么办？心态也变得不好，（为什么有了问题就心态不好呢，长久的不能解决问题造成的），出现的次数多了，当你再遇到问题时，就是一个扭曲的心态了， 扩散到一个的方方面面，那这个人就出了问题， 就在你出了问题后，你也不知道该怎么做？ 去纠正也不知道怎么做？只能头疼医头，脚疼医脚，一个问题接着一个问题，貌似解决了问题，但是心态一点都没有改变，更有可能因为问题的不断出现，导致心态越来越差
问题2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉

能力的总结
1.轻松的的心态，把所有的经历都专注在你要做的事情上，其他的任何东西都不要，本身要搞清楚，搞透彻，(关键是找准主方向)，然后延伸，发散，优化，总结等（满足于当前，没有更进一步的思考。）=》发散与集中，战略上发散，战术上集中
2.一个大的工具如wcf，一个小的方面，如wcf中behavior，都需要了解知识点，概念，运作机制，然后再一步一步的走下去，这样才算是理解透彻，甚至还包括修改参数带来的影响。=》这是学习知识的问题
3.找准主方向，一切都会迎刃而解的，关键如何找到主方向呢？


开始本节课前，应该思考这些东西 0.积极的心态 1,这节课讲的是什么，大概概况，解决的问题，2。新知识还是旧知识 3.旧的话自己的本身的认识是什么？用到饿了那些什么样的基础知识 4.新知识的话，该怎么办？5.根据用途猜想下它的实现 6.
结束本节课后，应该思考这些东西 1.学到的知识是什么？心中是否清晰？2.自己独立思考下 3.和自己预想的有什么不一样？ 4.有什么方法或者思维或者见识可以借鉴 5.总结下



问题1：之前讲到的更多的是client和service之间的传输，但是服务在service是如何存在的就没有涉及到，此时开始就涉及到了，
问题2：老习惯，分分类，
问题2.1遇到新名词，新概念该怎么办？ 可不是浏览下就跨过去的，=》另外为什么不事前猜下实例行为指的什么？
问题3：各个行为为什么会归类各自的类呢， 分类的依据呢？就是实例行为为什么是服务行为？
问题4：一个东西有那几部分，运行从开始到结束是如何进行的？=》三个调用说明了什么问题？=》量级的增多 带来的问题
问题5：此时理解了服务行为  单例模式  重量级  多线程访问，提高性能，
问题6：初次看single+percall是什么感受？啥东西呀，不知道， 这是自己单单去看字面的结果，此时自己又不会，也不知道去找到能解释的文章，一片迷茫，但是听完之后呢，完全清楚了， 
问题7：首先它是一个服务行为，所以说它是控制这个服务实例的  一个是实例行为，那么就是instance
问题8：单实例的构造函数是如何执行的？ 预想是第一次调用new一下，然后后续的不再new，
问题8:串行 多线程，控制同步  有些还是需要例子来佐证的
问题9：性能高，对比发现， 这就是性能高呀， 有时候说性能高，感觉不出来，这次就直观感觉出来了  有些还是需要例子来佐证的 =》提高性能的问题，找对主方向，如本课中，可以从实例行为和并发行为入手，那如何知道实例行为和并发行为入手呢？
问题10：察觉出和之前的不同  自己发现一个小问题，我想知道构造函数和dowork的执行前后顺序
问题11：为什么我没有想到这个问题呢？=》如果我是在看文章时，梳理一个脉络，还有可以的=》但是如果是要自己去面对一件事，随着事情的发展去梳理的话，还有有问题的，
ok接下来，我们在来面对什么问题呢、 
问题12：看到新名词，搞定它， 当然直接看MaxConcurrentInstances这个词，第一感觉是不知道干嘛的，首先要知道instance session call的含义，然后再去了解运行机制，套在其中，发出影响
问题12.1这些都是对service而言的，所以配置也就是service，既然是行为，应该在webconfig中



大家好，从本节课开始，我们就和大家来说下这个behaviors，那么behaviors的话呢，是wcf的一个运行时的一个行为控制，所以叫behavior，
问题1：之前讲到的更多的是client和service之间的传输，但是服务在service是如何存在的就没有涉及到，此时开始就涉及到了，
那么 ok我们在之前的课程中，和大家讲到了，有一个wcf的一张图，这张图上呢，有一个服务运行时  哪些行为对不对，ok 我们就来看下 
问题2：老习惯，分分类，
问题2.1遇到新名词，新概念该怎么办？ 可不是浏览下就跨过去的，=》另外为什么不事前猜下实例行为指的什么？
其实我们可以把behavior大概可以分为三类，
第一类叫做服务行为
第二类叫做端点行为
第三类叫做操作行为

问题3：各个行为为什么会归类各自的类呢， 分类的依据呢？就是实例行为为什么是服务行为？
我们可以对照这个图，服务行为它的名字叫做servicebehavior，哪些属于servicebehavior呢， 主要是实例行为，然后事务行为，然后并发行为，然后限制行为  这四种我们都可以认为是服务行为，
然后端点行为，那端点行为做什么呢？做消息检查 调度行为
然后操作行为，那操作行为的话，可以做参数筛选，
ok常规的话，七个行为， 这么多东西的话， 我们是准备做4节课，给大家去讲，
那么本节课的话， 我们首先给大家讲服务行为
首先服务行为有实例 事务 并发 限制这四个行为，  事务行为放到下节课去讲，因为 这个东西内容还是蛮多的，
ok，本节课我们就讲下实例行为 并发行为 限制行为
首先的话，服务行为分三类  我们就想下它的这个场景吧，我们看下它的这个场景，就是说为什么要有服务行为，  服务行为呢 能够控制这几个，那为什么，
我们先来说实例行为和并发行为， 就是说什么意思呢？ 为什么要控制实例行为，我们在之前的课程中，一直都用homeservice来给大家演示，对吧，

问题4：一个东西有那几部分，运行从开始到结束是如何进行的？=》三个调用说明了什么问题？=》=》量级的增多 带来的问题
ok，我来画一张图把，辅助大家理解，比如说我们这个地方是， 一个client 一个service（homeservice），ok，问题就来了额，既然是一个rpc调用，对不对， 那么必然会存在着 比如说我有三个调用，call1 call2 call3，那么实例行为呢，就是说我是new这个homeserice，对不对， 那这个new的话，问题就来了额，我是call一次new一次，还是只new一次，那这个就叫做实例行为，
问题5：此时理解了服务行为  单例模式  重量级  多线程访问，提高性能，
这个问题的话就是一个服务行为的问题了
其实大家呢 学过设计模式的话，肯定知道 后面一种是属于单例模式。 那前面的话，就没什么模式了，
ok，这个的话是一个实例行为，
那单例模式的好处，大家应该也知道， 它的构造函数是私有的，对不对， 而且的话，这个构造函数只会new一次，比如说构造函数重量级，因为你里面可能初始化数据比较多，这个时候我们用单例模式是特别好的，对吧，
ok，接下来的话呢，并发行为，
并发行为是什么意思呢？就是说你 不是new了一个homeservice的实例嘛？因为你不管是new一次，还是new多次，你最终都是有一个实例，对吧，也就是说 new后的homeservice实例，是如何接受线程，thread，？ 什么意思呢，就是说你这个homeservice实例能够接受多个线程吗？或者说只接受一个线程，那这又是一个维度，对不对，你这一个实例能够接住多线程，还是说你只让一个线程访问，还是让多个线程访问？
ok，这个的话，又是一个值的思考的，如果说你能够让多线程去访问的话呢，这个homeservice实例必然会提高性能 （也就是实例的能力增强了）对不对，如果你这个实例只提供一个线程访问的话，确实性能慢，但是比较安全，对吧 
这个是一个并发行为，就是说这个实例接不接受多线程访问，
ok，这就是我给大家说到的两个场景，

问题6：初次看single+percall是什么感受？啥东西呀，不知道， 这是自己单单去看字面的结果，此时自己又不会，也不知道去找到能解释的文章，一片迷茫，但是听完之后呢，完全清楚了， 
我们默认情况下呢，WCF是如何处理的呢，它是一个single+percall  这是什么意思？ percall就是说每来一次，new一次，就是这个地方call一次new一次，来一次call一次，，，然后我只接受单线程，那这个是什么意思？就是说我call一次，我只接受一个线程访问， 那其实大家可以想一下，它其实本质上就是一个多线程，对不对，因为你调用一次，new一次，call2的时候，复用不了call1时的实例，，对不对，所以说的话，默认情况下是，来一次请求new一次homeservice，一个new接受单线程， 所以说的话呢， 这个其实本质上就是一个多线程，对不对，因为你 call一次，new一次，完了之后你call完了之后，new的实例马上就销毁了， 对不对，
ok。这个的话 就是wcf的默认情况，
接下来的话，我们如何来做一些其他的一些配置，比如说，我把它改成单例的， 这个时候我们来看下，他会是一个什么样的？
实例我们是单实例，线程也是单线程
比如说，我们常用的一个组合就是一个single+一个single 看看请求是不是串行的？
ok，给大家来演示下，
问题7：首先它是一个服务行为，所以说它是控制这个服务实例的  一个是实例行为，那么就是instance
如何配置，因为是一个behavior对不对，  在那个地方加呢？ 首先的话呢，它是一个服务行为，对不对，所以说它是控制这个服务实例的，对吧，所以按理说应该在Homeservice上添加比较合适，因为他是实例嘛
所以说 用ServiceBehavior特性， 刚才说到的，一个是实例行为，那么就是instance，查查有什么，发现InstanceContextMode  这是一个枚举第一种是percall，然后是persession， persession的话呢，就是我们使用会话形式的binding，比如说wshttpbinding，这个的话是每一个会话，共用一个实例，这个perssion我们用不到， 我们基本上能用到就是single和percall，ok。这个地方我们采用的是单实例，，
然后接下来的话呢，并发行为，应该是concurrency，查查有啥，发现ConcurrencyMode这个枚举，你这个服务的线程呢是采用单线程，，ok，我们也是调用这个dowork， 调用dowork，我们把这个时间给它打出来，（验证是否单线程），接下来的话呢，我们测试单实例，单实例的话，我们可以在构造函数中输出下，如果说只输出一次，真的是单实例，
  [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Single)]
    public class HomeService : IHomeService
    {
        public HomeService()
        {
            Console.WriteLine("我是构造函数。。。。");
        }

        public void DoWork(string msg)
        {
            Console.WriteLine("datetime={0}, msg={1}", DateTime.Now, msg);

            Thread.Sleep(3000);
        }
    }
运行下，这时候看到，输出
我是构造函数。。
wcf启动成功
问题8：单实例的构造函数是如何执行的？ 预想是第一次调用new一下，然后后续的不再new，
这时候我们就发现了，当wcf的宿主启动后，他在servicehost构造的时候，它就已经把实例初始化呢，就是 （可以发现，serviceHost启动的时候，就已经给我new出了一个HomeService实例。。。）
此时，还没有验证单实例  看后续是否有新的输出

问题8:串行 多线程，控制同步
我们在dowork函数中，线程休眠3秒，看看是否是单线程，也就是串行
client添加服务引用，
client段的代码，做100次调用， 看构造函数输出和dowork输出
 static void Main(string[] args)
        {
           for(i=1,i<=100,i++)
		   {
                Console.WriteLine(item);

                HomeServiceClient client = new HomeServiceClient();

                client.DoWork("hello world!");
            };

            Console.Read();
        }


或者严格点，多线程调用client端的调用代码
 static void Main(string[] args)
        {
            Parallel.For(1, 100, (item) =>
            {
                Console.WriteLine(item);//item就是个索引

                HomeServiceClient client = new HomeServiceClient();

                client.DoWork("hello world!");
            });

            Console.Read();
        }
启动client端，启动完后看下服务端输出，
此时我们client是并发调用，服务端是单线程访问实例，
我们可以看到client端输出了item（1到100的随机数，因为是多线程嘛，不是串行），而且client都输出了好多个item，服务端才输出一两个，而且是串行输出，时间间隔3秒（为啥是串行呢，因为看时间呀）
ok这个就是，给大家演示的 single+singe的模式
接下来，我们再说第二种 single+multi 实例是单实例，实例接受多线程  这个有什么好处，实例是单实例的话，可能你这个实例里面有特别多的初始化，就是重量级的构造函数，这个时候你但实例再接受多线程， 这个大家一定要注意一个风险就是，自己控制同步，
我们修改下代码

 [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    public class HomeService : IHomeService
    {
        public HomeService()
        {
            Console.WriteLine("我是构造函数。。。。");
        }

        public void DoWork(string msg)
        {
            Console.WriteLine("datetime={0}, msg={1}", DateTime.Now, msg);

            Thread.Sleep(3000);
        }
    }

然后运行下service和client
我们发现也是servicehost初始化的时候，实例也就new了。

问题9：性能高，对比发现， 这就是性能高呀， 有时候说性能高，感觉不出来，这次就直观感觉出来了 =》提高性能的问题，找对主方向，如本课中，可以从实例行为和并发行为入手，那如何知道实例行为和并发行为入手呢？
这个时候就发现了和刚才不一样了 client输出一个item，service就输出一个dowork信息  对不对
这个的话，service的性能就可以想想，性能是比较高的，为啥？对比下刚才的输出和现在的输出，（输出就代表处理速度，处理速度就代表性能），一个快一个慢呀，快的当然性能高？
我们总结下，single+single 安全但性能差， single+multiple  不安全但性能高
 
 ok，我们还有那些组合呢？
 precall+single 默认的， 每次call都new一次， 然后并发行为，单线程和多线程其实是无所谓的额，

 然后我们看下默认情况的 实例的构造函数的输出
 修改代码
  //[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]
    public class HomeService : IHomeService
    {
        public HomeService()
        {
            Console.WriteLine("我是构造函数。。。。");
        }

        public void DoWork(string msg)
        {
            Console.WriteLine("datetime={0}, msg={1}", DateTime.Now, msg);

            Thread.Sleep(3000);
        }
    }
问题10：察觉出和之前的不同  自己发现一个小问题，我想知道构造函数和dowork的执行前后顺序
启动service，我们发现一个什么问题，我们发现它并没有走实例的构造函数，对不对，它并没有走， 那什么时候走呢？
然后启动client，并行的调用下， 我们发现什么，我们发信client每调用一次，service就输出一个构造函数，而且service的处理能力也是并行的， 这个为什么是并行的，因为你来一次我new一次，相当于single+multi场景，表象上是这样的，其实本质上还是不一样的， 所以说它的性能肯定是比single+multi要差， 对不对，可想而知，多了个构造函数 ，每一次调用就new一次，每new一次就要走构造函数，这个大家一定要知道哦， 验证了每次call就new一次，

问题11：为什么我没有想到这个问题呢？=》如果我是在看文章时，梳理一个脉络，还有可以的=》但是如果是要自己去面对一件事，随着事情的发展去梳理的话，还有有问题的，
ok接下来，我们在来面对什么问题呢、 
可以考虑，如果说我client发出了1w个call，那你service要new一万次，对不对，每个new的话都用一个单线程，也就是默认的precall+single，那这时候会有一个什么样的问题呢？你这个service这台机器还能不能承受得了，对不对， 那这个的话是第一个问题，是concurrent的一个问题，还有一点 你单实例多线程那这个风险 第一个是同步第二个的话呢，如果我call一万次，你用一万个线程吗？或者你用一个线程池实时的接受一万个call吗？
第一个如果过大的call，会导致什么？会导致机器崩溃，，所以说，我们要在service端做一个安全阈值，也就是下面给大家讲到的 
那么这个阈值是怎么控制呢？控制什么？

问题12：看到新名词，搞定它， 当然直接看MaxConcurrentInstances这个词，第一感觉是不知道干嘛的，首先要知道instance session call的含义，然后再去了解运行机制，套在其中，发出影响
问题12.1这些都是对service而言的，所以配置也就是service，既然是行为，应该在webconfig中
MaxConcurrentInstances : 设置同一时刻服务上下文实例的最大数量。（疑问）【perSession 和perCall 起作用】【对Single不起作用】
MaxConcurrentSessions : 设置同一时刻可以接受的最大会话数量。
MaxConcurrentCalls : 设置 ServiceHost 消息并发处理的最大值。（疑问）【Single 和 Multiple 控制线程的数量】【对Single也起作用】
		     每个实例来了，都用一个线程池线程，那最多控制在多少个线程忙碌中。

第一个的话呢，我们可以控制这个最大的同步实例数，上下文实例的最大数量，比如说呢 你来一次我new一次这是默认配置，如果我来了十亿次请求呢，那你是不是要new十亿次呢，对不对，你是不是要new十亿次呢，实例的话（既MaxConcurrentInstances）对single不起作用（此时的single是实例行为）肯定对single不起作用，single只有一个实例，就不存在一个控制实例的问题了，对不对，所以说这个（MaxConcurrentInstances）只读precall和presession 也就是默认的起作用。MaxConcurrentInstances这个是控制实例的数量，你不能说不限制的去new这个实例，那这样的话你内存堆也受不了，对吧，
第二个话呢是一个MaxConcurrentSessions， 这个我们不考虑
第三个是MaxConcurrentCalls calls相当于是什么呢 每一个实例来了，对不对，可能我都要用一个线程池中的一个线程去处理， 那这个的话，其实的话就是控制线程的一个数量， 也就是并发处理的最大值，
大家要理解下，一个是控制线程的数量（MaxConcurrentCalls），一个是控制实例的数量（MaxConcurrentInstances）,这个MaxConcurrentSessions大家做一个简单的了解。
ok，比如说我举个例子
比说我采用默认的配置，就是percall+single
如果此时我把MaxConcurrentInstances改为1，也就是说同一时刻只能有一个实例存在，那这个的话，相当于是， 有点像单实例，也不能说是单实例，这时候 以前的情况下，我可能是并发的，对不对，控制台可以输出很多，那如果是我同一时刻只能有一个实例的话，就相当于给它加了一个队列，队列的容量是1，对不对， 
我们可以来试下，
那这个地方是如何来配置的，
 <behaviors>
      <serviceBehaviors>
        <behavior name="">
          <serviceMetadata httpGetEnabled="true" httpsGetEnabled="true"/>
          <serviceDebug includeExceptionDetailInFaults="false"/>
          <!--<serviceThrottling maxConcurrentCalls="1"/>-->
          <serviceThrottling maxConcurrentInstances="1"/>
        </behavior>
      </serviceBehaviors>
    </behaviors>
此时Percall + Single  
设置MaxConcurrentInstances：1 （同一时刻只能有一个实例存在） 此时表象类似于单实例，实现了串行效果。

如果我采用单实例多线程， Single + Multi 
设置MaxConcurrentCalls：1，同一时刻只能一个线程跑  此时是不是等于single+single  是不是，我们可以看下，同样实现了串行的效果




一：WCF的Behavior【运行时改变wcf的行为】

常用的behavior

服务行为 【ServiceBehavior】 　　　 实例行为　＋　事务行为　＋　并发行为　＋　限制行为
端点行为：【EndPointBehavior】　　　消息检查　＋　调度行为
操作行为：【OperationBehavior】　　　参数筛选

1. 服务行为 【ServiceBehavior】

   控制实例化+ 并发+ 事务

2. 场景： 【实例行为 + 并发行为】

  call 一次  new HomeService 吗？ 还是只new一次？？？【single模式】 =》【构造函数重量级】

  new HomeService() 是如何接受Thread的？？？ 一个线程访问还是让多个线程访问？？？
  

默认情况下： Single + PerCall  （来一个请求new一次homeService，一个new接受单线程）

<1> Single + Single  看看请求是不是串行的？？？  【安全 + 性能差】

可以发现，serviceHost启动的时候，就已经给我new出了一个HomeService实例。。。

            Parallel.For(1, 100, (item) =>
            {
                Console.WriteLine(item);

                HomeServiceClient client = new HomeServiceClient();

                client.DoWork("hello world!");
            });

<2> Single + Multi  单实例（多线程） => 风险（自己控制同步） 【不安全 + 性能优】 

<3> PreCall + Single（Multi） 【默认】

[ServiceBehavior(InstanceContextMode = InstanceContextMode.Single, ConcurrencyMode = ConcurrencyMode.Multiple)]


<4> 如果过大的call，会导致机器奔溃。。。


3. 在构造函数中配置的‘安全阈值’，提前评估机器负载 和 处理能力

   当然这个是死值，其实你还可以根据分钟数，cpu当前利用率来动态拒绝客户端请求，这个档次才高。

    <behaviors>
      <serviceBehaviors>
        <behavior name="">
          <serviceMetadata httpGetEnabled="true" httpsGetEnabled="true"/>
          <serviceDebug includeExceptionDetailInFaults="false"/>
          <serviceThrottling maxConcurrentCalls="1"/>
        </behavior>
      </serviceBehaviors>
    </behaviors>

MaxConcurrentInstances : 设置同一时刻服务上下文实例的最大数量。（疑问）【perSession 和perCall 起作用】【对Single不起作用】
MaxConcurrentSessions : 设置同一时刻可以接受的最大会话数量。
MaxConcurrentCalls : 设置 ServiceHost 消息并发处理的最大值。（疑问）【Single 和 Multiple 控制线程的数量】【对Single也起作用】
		     每个实例来了，都用一个线程池线程，那最多控制在多少个线程忙碌中。

Percall + Single  

MaxConcurrentInstances：1 （同一时刻只能有一个实例存在）


Single + Multi  +MaxConcurrentCalls：1 （同一时刻 是能一个线程跑）  = Single + Single

