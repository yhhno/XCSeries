wcf,rabbitmq,asp.net core 分布式视频，鬼谷子，麻宁这么好的东西，我怎么能忍受它放在那里睡大觉呢？ 不赶快吸收吸收，就算装装逼也好呀，是不是？

情绪上怎么样? 小事情，搞的定，一步一步来，不要有过多的任务压在心头，与完事开头难的矛盾， 退缩是不存在额，没有在怕的。=》  主动的话，这些问题就可能不存在，反而有其他更好地东西出现
我是来学学习能力的，学习方法论的，不仅仅是知识？ 不是学完就万事大吉了，=》本质
这个点没有评价好坏，未来的预期也没有评价好坏？
每个东西，都要深挖，不能只是了解它的作用，
每个新东西，旧东西， 其实都不难，调整好状态，跨出第一步，步步踏实，有啥难的，一多半都是自己吓自己。
既然心理作用这么大，我们可以怎么做呢？  之前用代入感，现在用成功者，也就是未来者（儿子清华，女儿北大）， =》积极主动
来句革命性的，这些东西真的有那么重要的吗？遇到它我不想学，产生退缩，我的一切都完了吗？ 当然不是的，我当然不是整天要面对不是这些事情，这些都是实现方式之一，人需要有哲学的角度，出一套指导思想，把一切都简略的画出来，然后去填空，而目前呢，只是在做填空的那一步，就像一个没有思想的人，那就是一个不知道为什么这么做的人在做事情，此时积极的发挥不出来，消极的全部放大，导致进展不下去。 
我们是思考抽象的高层次东西，怎么可以困在低层次的范围内呢？ 对不对？

必须要有整体上的认识，才可以去理解其中的概念，名词，底层的流程，抽象的流程，抽象的概念 大局观
各个点的知识知道了，但流程是什么呢？ 如何联系在一起呢？逻辑呢？  如何才算是理解透彻？概念的透彻，流程的透彻
什么是理解透彻呢？ 就是画一张图来概括，一定要学会这种方式， 知识点都串起来了，形象生动。记忆深刻  
##note###重大问题，基础知识不系统，不全面，有缺失，而且还不清晰牢固

之前总结，反思了很多东西，为什么效果平平呢？ 很大可能是激情没有涉及，（我一定杀20个人呢，）=>起势的东西没有。=》有了起势的结果是什么？=》遇到新东西一定搞明白，事情一定要完成，还有呢？
我就是要知道，既然是学习知识，首先先学到知识，然后在学到学习方法，如何实现呢？
感觉越学越简单，越容易，他妈的就是很简单嘛。
我相信只要我持续的思考，学习，我一定能掌握一套东西，然后学任何的东西都得心应手，都透彻，然后都应用的很好《=《精神层面最重要，不然就没有行动上的启动了，更别说方法的改进了和知识点的累积了》=>有一个方针，或者标准 如成才四标准和人际关系三种关系

 解决IT企业的信息孤岛问题。=》根本就没理解这句话的含义，，不够聪明。不够，缺点啥呢 另外，我们往往仅仅着眼于运用，更进一步是实现，但是都不是从0开始，演变也不清楚，当然更别谈什么导致了演变，环境的变化，（这是基本情况的梳理） 更别谈了，种种的归类，总结，对比（这是提炼出理论，抽象的东西）

 他学习得到东西和我学习得到的东西，为啥不一样？ 是由什么造成的呢？ 我也来对比下，（当然分自学和别人教授两种情况了）
问题的出现，都是能力的欠缺或者是不足造成的额， 此时的重点是补全能力，而不是关注表面的东西，======》》》》总结能力，必须总结，这是最终的关键地方
如果我没有了学习视频，自我学习一个技术，一个领域咋办呢？

问题7：谁有什么？ 一定要搞清楚，不能乱套用，都不清晰，当然稀里糊涂的，一定要界定清楚，说明学习时方式有问题，或者总结时有问题=》引申个大问题，你遇到的各种问题是因为你不具备某种能力，如果你具备了能力，这就不是问题，而是做事的步骤而已，它就不会拦着你，此时就不知道怎么办？心态也变得不好，（为什么有了问题就心态不好呢，长久的不能解决问题造成的），出现的次数多了，当你再遇到问题时，就是一个扭曲的心态了， 扩散到一个的方方面面，那这个人就出了问题， 就在你出了问题后，你也不知道该怎么做？ 去纠正也不知道怎么做？只能头疼医头，脚疼医脚，一个问题接着一个问题，貌似解决了问题，但是心态一点都没有改变，更有可能因为问题的不断出现，导致心态越来越差
问题2：交互，只想到在powshell中去操作，而且还有可能困在这个操作中，觉得好难哦，根本就没想到交互，用C#代码交互， 这说明知识面不够，仅仅满足于当前，没有更进一步的思考。
问题8：都是承载wcf，iis中有什么不同呢？=》环境变了，其他的东西变了吗？=》要察觉到环境变了，=》然后看到底细节有哪些不同，=》webconfig有什么不同？ 我们们发现
问题9: 对哦，既然这个项目不是部署到iis上的，所有当你调试的时候，能够启动成功，说明就是运行在iis环境上，=》察觉
问题10：很多情况就是我们对整个流程不清楚的情况下，去看概念，去应用，这样是不正确的



能力的总结
1.轻松的的心态，把所有的经历都专注在你要做的事情上，其他的任何东西都不要，本身要搞清楚，搞透彻，(关键是找准主方向)，然后延伸，发散，优化，总结等（满足于当前，没有更进一步的思考。）=》发散与集中，战略上发散，战术上集中
2.一个大的工具如wcf，一个小的方面，如wcf中behavior，都需要了解知识点，概念，运作机制，然后再一步一步的走下去，这样才算是理解透彻，甚至还包括修改参数带来的影响。=》这是学习知识的问题
3.找准主方向，一切都会迎刃而解的，关键如何找到主方向呢？ =》主方向是脉络清晰的升级，更进一步。
4.要开心快乐。


开始本节课前，应该思考这些东西 0.积极的心态 1,这节课讲的是什么，大概概况，解决的问题，2。新知识还是旧知识 3.旧的话自己的本身的认识是什么？用到饿了那些什么样的基础知识 4.新知识的话，该怎么办？5.根据用途猜想下它的实现 6.
结束本节课后，应该思考这些东西 1.学到的知识是什么？心中是否清晰？2.自己独立思考下 3.和自己预想的有什么不一样？ 4.有什么方法或者思维或者见识可以借鉴 5.总结下



问题1：画个图，容易理解，效果好比大白话，引出分布式事务的必要性
问题1：单机版的acid什么意思？ 有什么局限？
问题2：Cap理论，新概念  每个点都是大白话，vs自己看的时候云里雾里 不慎其意
问题3：可用性，可用啥意思呢？应该想用就能用，及时响应的意思
问题5：如何理解协调器的作用，运作流程是啥？2阶段是哪两阶段？
问题6：性能低怎么办？增加性能？ 队列，异步
问题4：选择的一个问题？ 介绍了优缺点，然后就是选择了。
问题6：卧槽，这句话，这么难理解， 他又如何检测是否支持会话呢
问题3:会话，为啥要有会话呢？事务流是啥意思呢？ 自己看的时候就是遇到太多不懂的名字，导致看不下去了。这里有大白话解释。 传入事务？ 事务范围？
问题3.1 其实很多概念，顾名思义的去想象，或者结合理论看个小案例，或者大白话或者类比下，就可以理解了，要突破第一次障碍，走下去，
问题3.2 之前看事务特性，一头雾水，看了也理解不了，看后心中没有概念，不知道是个啥东西，看了就惧怕，这东西是啥东西呀， 这里看了一个小例子，就理解了。
问题9：老问题呢，潜意识认为，服务引用只能添加一个，因为一直都是添加一个，所以就认为只能添加一个了，这就是典型的没找对主方向，或者没找主方向  还有BusinessLayer中有两个dbml文件，一样的道理。
问题10：很多情况就是我们对整个流程不清楚的情况下，去看概念，去应用，这样是不正确的



大家好，这节课，给大家说下wcf的事务
那么首先的话呢，我们知道事务它具有一个acid的一个特性，但是的话呢，这个acid的话呢，它是一个单机版的， 
ok，我们本节课给大家讲到的是分布式事务， 
分布式事务大概是什么意思呢？也就是说我多个note节点上呢，我可能要做，都要做一个操作，就是什么意思呢？ 将多个节点上的操作 纳入 一个执行单元里。 这个执行单元的话，要么一起提交，要么一起失败，

问题1：画个图，容易理解，效果好比大白话，引出分布式事务的必要性
ok，我们可以画一张简图，
比如说 
有一个client端 地址为192.168.10.10，
有一个ProductDBService服务 地址是192.168.10.1，
有一个OrderDbService服务 地址为192.168.10.2
client对ProductDBService服务，这个的话，我可能要做一个库存的一个 productNum--的一个操作
client对OrderDbService服务，这个的话，我可能要做一个 AddOrder的一个操作，
这个的话呢，其实就涉及到分布式事务的一个问题，对不对，

问题1：单机版的acid什么意思？ 有什么局限？
如果说你用单机版的 acid的话呢， 你是做不到的， 你怎么做呢，你无法做
ok，那么这个的话呢，就是说将多个节点的操作，纳入 一个执行单元里，

问题2：Cap理论，新概念  每个点都是大白话，vs自己看的时候云里雾里 不慎其意
那么 ok 我们再来说下，CAP理论，
cap理论的话，严格来说，对不到wcf上去，对应不了wcf，为什么？ 
因为首先的话呢， 有一个p，这个是cap的基础，先有p，p的话，是什么意思？p的基础就是分布式， 因为，为什么？ 因为我们wcf本身就不是一个分布式的，对不对 ，它只是webservice模型的一个服务，对不对，但是的话呢，刚才的话呢?分布式的基础是就是集群，对吧， p的分区容错性， 就是说某些网络阻塞或者机器挂掉不影响这个集群，比如说我们这个wcf集群， 对不对 p是基础，如果你不满足p的话，就不是一个所谓的分布式的一个系统了，对不对，
我们还有一个c，c的话呢，叫一致性，那么一致性是什么意思？ 一致性的话，就是说数据最终都能够落地的， 但是这个落地的时间 分 立即落地（强一致性） 还是 某些时间之后再落地，那这个的话，叫最终一致性，
问题3：可用性，可用啥意思呢？应该想用就能用，及时响应的意思
然后的话，还有一个A，可用性，可用性的话就是说，我做 这个分布式的一个操作 的话，最终响应时间是几秒呢？比如说是1s，还是10s 还是1min，还是1hour，对吧，这个的话，都影响到你这个系统的一个响应性能的一个问题， 一般来说呢，1s以下还是能接受的，如果说我做一次操作，要1hour，那也没法做了。 对吧
那么这个就是一个分布式系统的一个理论，
ok，大家要了解下，

问题5：如何理解协调器的作用，运作流程是啥？2阶段是哪两阶段？
接下来的话，我们再来说下，分布式事务中一个经典的2pc的一个提交方式，2pc的话，是怎么做的呢，2pc的话呢，就是说 它中间引入到了一个协调器，将2pc呢变成了什么呢?变成了，多个节点的curd的操作， 比如说，我做这个productdbservice的话， 我把它变成curd，orderdbservice也是一个curd，，那么最终呢，需要一个中间者来协调的， ok，我们来给大家聊下，这个cap理论的2pc把，
2pc就是两阶段的意思，有一个productDBservice服务 地址是192.168.10.1，有一个orderdbservice服务地址是192.168.10.2，有一个事务协调器，地址是192.168.10.3,还有一个client端，它分两阶段嘛，第一阶段的话 是干嘛呢，第一阶段就是说事务协调器他发起请求，它发起请求（协调器向各个服务节点发起请求：1.准备提交），准备提交，或者说准备， 准备提交不是提交， 那么这个前面的话呢，就是我们的client端，发起请求，client的话呢，向这个事务协调器发起请求， 发起请求的话呢，，第一个阶段是准备提交，那么准备提交之后，他就要给一个回馈（各个服务节点要给事务协调器一个回馈 2.ok），或者严格来说，事务协调器向各个服务节点发起请求（1.事务来了或者请求来了做好准备），然后各个节点反馈（2.ok），那么请求来了，各个服务节点，要做一个什么操作呢， 它做一个，比如说我们这个地方有一个db，或者说我们有一个txt文件， db更好一点吧啊，比如说我们有一个db，各个节点服务会向这个db，写一些日志， 比如说写一些log，本地日志嘛，方便于我们查数据的，，ok，当然的话，你写到db或者写到本地的txt，或者本地的sqllite，都是可以的，然后最终我们同步到一个集中化的日志里面， ok，第二步是ok（准备好了），ok完了之后，的话嗯，事务协调器都收到各个节点服务的ok，，那么接下来，他就要回馈了， 第三步的话，他发送一个commit，commit的话，就告诉各个节点服务准备提交，commit完了之后，各个节点服务也要给事务协调器一个回馈，同样的话，各个节点服务返回一个ok（执行成功），有些地方可能是第四步省掉了，省不省掉都一样，。ok，大概是这样的一个模式，那我们可以看到的话， 我们可以看到什么呢， 看到2pc其实本质上它是有一个中间的一个事务协调器，如果说事务协调器挂掉了，那这个2pc就完成不了， 所以说呢事务协调器你可以做成一个集群
ok，那么wcf的分布式事务它是怎么做的呢？他其实本质上也是一个2pc的一个操作，
那么2pc有什么坏处呢，或者说 2pc它是一个性能非常低的一个分布式事务，但是呢能够保证这个强一致性，
ok，第二步的准备好了，准备好了的操作就是什么？就是curd 他已经做了事务，但是并没有提交，最终是由事务协调器呢来做这个commit操作，就是第三步，
那么等一下我用wcf的代码来演示下，2pc这张图，
ok，我再来说下，这个2pc 性能比较低，完全依赖于事务协调器，但是可以保证强一致性，

问题6：性能低怎么办？增加性能？ 队列，异步
性能比较低的话，我们还有其他的方式， 比如说我们使用队列，来解决这个问题（性能低劣）， 这个是给大家一个延伸，
比如说我们经常去饭店吃饭，对不对，吃饭的话，我们第一个有一个交钱的操作，交完款之后，有一个小票， ok，我们可以拿着这张小票，最终可以取的到你的饭菜，对不对，那这个的话呢， 小票的话，其实就是一个  那其实这个交钱和拿饭是一个事务性操作，对不对，所以说这种事务的话呢，你可以用一个小票来关联，，那这样的话呢，它能够使用异步的方式来增加性能，这个是最终一致性，但性能优越，对不对 这个最终一致性现实中可能要等20min或者30min， 那你这个20min或者30min，用户能不能接受呢，那这又是一个场景的问题，

问题4：选择的一个问题？ 介绍了优缺点，然后就是选择了。
最终一致性+性能优越
强一致性+性能低劣
所以说cap理论的话，c和a无法同时满足，你要一致性，那你的可用性必然低，就是2pc，你要可用性高， 绝对是最终一致性的 就是队列 ，所以说大家在自己的场景中自己去抉择把。
当然的话，这个选择取决于你的用户场景了额， 你可以用2pc或者用队列来实现

ok，接下来的话，我们就要看下wcf如何使用2pc的，wcf是采用强一致性+性能低劣来实现分布式事务的。
ok，我们来看下wcf如何来实现这么一个操作。

有一个productdbservice服务，有一个orderdbservice服务，每个服务都有一个db，各有一张表，product表和orders表， 
因为我现在要做一个什么样的操作呢？一个减库存，一个增加订单，你来了一个订单，我这个库存肯定要减一。对不对， 
我们先来看下productdbservice的项目
逻辑操作是这样的，有一个自减的操作，  public void DecreaseNum(int productID)
那orderdbservice项目
逻辑操作是这样的，有一个添加订单的操作， public void AddOrder(Model.Orders order)
此时有两个wcf，

接下来我们看有几个步骤
1. 服务契约上需要指定一定需要会话的binding，不是的话，会抛出异常。  [ServiceContract(SessionMode = SessionMode.Required)]

2. 操作契约上一定要指定该操作可以作为事务流的一部分。[TransactionFlow(TransactionFlowOption.Allowed)]

3. 实现方法上需要指定该方法纳入事务TransactionScope事务范围  [OperationBehavior(TransactionScopeRequired = true)]

4. config中指定支持会话的binding，并开启事务流支持。

第一个步骤的话，我刚才也讲到了，服务契约上要指定会话,所以binding一定要支持会话， 也就是你这个binding你不能用basichttpbinding，

问题6：卧槽，这句话，这么难理解， 他又如何检测是否支持会话呢
指定协定需要会话绑定，如果绑定为未配置为支持会话，则将会引发异常
    [ServiceContract(SessionMode = SessionMode.Required)] 要求binding必须支持会话，不支持的话，你实现不了分布式事务
    public interface IProductService
	或者
	   [ServiceContract(SessionMode = SessionMode.Required)]
    public interface IOrderService
问题3:会话，为啥要有会话呢？事务流是啥意思呢？ 自己看的时候就是遇到太多不懂的名字，导致看不下去了。这里有大白话解释。 传入事务？ 事务范围？
问题3.1 其实很多概念，顾名思义的去想象，或者结合理论看个小案例，或者大白话或者类比下，就可以理解了，要突破第一次障碍，走下去，
问题3.2 之前看事务特性，一头雾水，看了也理解不了，看后心中没有概念，不知道是个啥东西，看了就惧怕，这东西是啥东西呀， 这里看了一个小例子，就理解了。
第二步骤是 将函数纳入到事务流，什么意思呢？ 我最开始也讲到了  将多个节点上的操作 纳入 一个执行单元里，这个执行单元的话，要么一起提交，要么一起失败，  对不对， 我将这个DecreaseNum纳入到分布式事务单元里，  我将这个AddOrder纳入到分布式事务单元里， 
 [OperationContract]
        [TransactionFlow(TransactionFlowOption.Allowed)]
        void DecreaseNum(int productID);
		或者
		     [OperationContract]
        [TransactionFlow(TransactionFlowOption.Allowed)]
        void AddOrder(Model.Orders order);
TransactionFlow指定服务操作是否接受来自客户端的传入事务 官方解释
TransactionFlow指定服务操作是否接受来自客户端的事务来源

我们来一一写下
首先，服务契约上指定会话， 
第二个是TransactionFlow，它的话，就是说操作契约一定要指定该操作可以作为事务流额一部分，事务可以成为流，
第三个实现方法 上需要指定该方法纳入TransactionScope事务范围  

        [OperationBehavior(TransactionScopeRequired = true)]
        public void DecreaseNum(int productID)
        {
            using (ProductDBDataContext context = new ProductDBDataContext())
            {
                var product = context.Product.FirstOrDefault(i => i.ProductID == productID);

                if (product != null)
                {
                    product.ProductNums--;
                    context.SubmitChanges();
                }
            }
        }
		或者
		 [OperationBehavior(TransactionScopeRequired = true)]
        public void AddOrder(Model.Orders order)
        {
            using (OrderDBDataContext context = new OrderDBDataContext())
            {
                context.Orders.InsertOnSubmit(new BusinessLayer.Orders()
                {
                    OrderID = order.OrderID,
                    OrderName = order.OrderName,
                    CreateTime = order.CreateTime,
                    ProductID = order.ProductID
                });

                context.SubmitChanges();
            }
        }
TransactionScopeRequired 该值指示方法在执行时是否需要事务范围

第四个自定义bindings 开启事务。
 <bindings>
      <wsHttpBinding>
        <binding name="mywsbinding" transactionFlow="true">
        </binding>
      </wsHttpBinding>
    </bindings>


然后在具体的函数中，操作db，这个地方建了两个db，一个是orderdb，一个productdb，第一个是ProductDBDataContext，做了一个查询，查询完了之后，我做了一个自减的操作，对不对，然后提交，  第二个OrderDBDataContext  相当于我是有两个数据库连接字符串，它是两个数据库上下文，
 using (OrderDBDataContext context = new OrderDBDataContext())
            {
                context.Orders.InsertOnSubmit(new BusinessLayer.Orders()
                {
                    OrderID = order.OrderID,
                    OrderName = order.OrderName,
                    CreateTime = order.CreateTime,
                    ProductID = order.ProductID
                });

                context.SubmitChanges();
            }
			或者
using (ProductDBDataContext context = new ProductDBDataContext())
            {
                var product = context.Product.FirstOrDefault(i => i.ProductID == productID);

                if (product != null)
                {
                    product.ProductNums--;
                    context.SubmitChanges();
                }
            }

问题9：老问题呢，潜意识认为，服务引用只能添加一个，因为一直都是添加一个，所以就认为只能添加一个了，这就是典型的没找对主方向，或者没找主方向  还有BusinessLayer中有两个dbml文件，一样的道理。
我client操作是怎么操作呢？ 我首先使用一个using，using完了之后，我先连接第一个wcf，然后第二个wcf，然后我做一个add操作，然后做一个decrease的操作，完了之后，再提交，
using (TransactionScope scope = new TransactionScope(TransactionScopeOption.RequiresNew))
            {
                ServiceReference1.OrderServiceClient orderClient = new ServiceReference1.OrderServiceClient();

                ServiceReference2.ProductServiceClient productClient = new ServiceReference2.ProductServiceClient();

                //1. 增加订单
                orderClient.AddOrder(new Orders()
                {
                    OrderID = 1,
                    CreateTime = DateTime.Now,
                    OrderName = "我的订单！",
                    ProductID = 1
                });

                //2. 减productID的库存
                productClient.DecreaseNum(1);

                scope.Complete();

                Console.WriteLine("事务执行成功！！！");
            }

我们来调试下，给大家看下，
启动两个service ，启动client
client端输出事务执行成功， 查看数据库 order表新增一条数据，product表num减一。


问题10：很多情况就是我们对整个流程不清楚的情况下，去看概念，去应用，这样是不正确的
如果在     scope.Complete(); 这里下个断点，调试，
大家对照着那张图。2pc的4个步骤，
client运行到断点处。
我们去看下数据库
刷新下product表和order表， 我们发现它两个正在查询，因为他是一个事务嘛， 你这个时候是看不到的，这就说明什么？这就说明了他们两个事务已经变成了一个大的事务里面去了，也就是说他两个是一个事务执行流， 要么一起成功，要么一起失败， 此时两个都处于阻塞的状态，这就说明什么？
我们对照着图，
这就说明我们现在还处于第2个阶段或者说我们还在处于第一个阶段， 第一个阶段请求来了，做好准备，然后返回ok（第二个阶段），事务协调器一直都没做第三步操作，commit，对不对， 如果时候你不做commit的话，两个节点准备好了，相当于做了事务的开启，但是并没有做事务的提交，那么提交是等待事务协调器来提交，
client并没有commit，导致第三步一直不执行，两个节点就一直等待，，这时候客户是没法操作的，对不对， 你看sqlserver查询会变成超时，  我再刷查询，事务超时了，
这就是给大家讲的2pc的一个提交，
很简单对吧
wcf严格遵从2pc处理，
ok我讲的这张图，这张图的核心是事务协调器， 既然wcf遵从的是2pc，那么他的事务协调器在哪里， 这就是一个非常底层的一个问题，因为这是wcf底层给我们支持的，那比如说我们可以看到 服务里面有一个什么东西呢？ 分布式事务协调
Distributed transaction coordinator  
协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。

我们可以把两个wcf部署到不同的机器上=>主方向不存在
ok，这就是给大家介绍的wcf的分布式事务，，很简单对吧，当然的话，说起来很简单，你真的做起来，真的是一个很复杂的一个东西，
当然很多电商项目 很难实现分布式事务，，所以会经常出现超卖的现象， 大家可以去网上去搜，

所以说这是一个很大的研究课题，wcf作为net下的一个大一统的框架，它是支持2pc模式， 当然你一定要忍受它的性能低劣






一：分布式事务

ACID[单机版的]

   将多个节点上的操作纳入一个执行单元里。【执行单元 要么一起成功，要么一起失败】

CAP理论:

Consistency(一致性)	        数据最终都能够落地 [立即落地(强一致性) 还是 某些时间再落地（最终一致性）]
Availability(可用性)            理想的响应性能 【1s？？10s?? 1min ? 1hour???】
Partition tolerance(分区容错性) 某些网络阻塞或机器挂掉不影响集群。


二：分布式事务实现方式 (CAP理论)

1. 2PC提交  [多个节点的CURD的操作]

将一个分布式消息 拆解成 多个单节点上的CURD，通过事务协调器来进行协调。

【准备阶段，执行阶段】，每个阶段都要想事务协调者汇报。 [性能低劣]

2PC性能比较低，完全依赖于 ‘事务协调器’， 但是可以保证强一致性。。。  【性能低劣】 + 【强一致性】

三：使用队列进行 ‘分布式事务处理’

1. ‘交钱’ 和 ‘拿饭’ 是两个动作。

   为了增加处理量，只需要给交钱的客户一个小票，然后在出货处等待叫号， 
   
  【小票来关联】

只要你有这个小票，就一定能拿到‘饭’的。。。   


【性能优越】+【最终一致性(20min,30min)】


四：WCF的分布式有DTC参与协调，它就是一个事务协调器，相当于2PC中的 事务协调器

    分布式事务，CAP理论中，追求最终一致性。

五：使用WCF实现分布式事务

步骤：

1. 服务契约上需要指定一定需要会话的binding，不是的话，会抛出异常。  [ServiceContract(SessionMode = SessionMode.Required)]

2. 操作契约上一定要指定该操作可以作为事务流的一部分。[TransactionFlow(TransactionFlowOption.Allowed)]

3. 实现方法上需要指定该方法纳入事务TransactionScope事务范围  [OperationBehavior(TransactionScopeRequired = true)]

4. config中指定支持会话的binding，并开启事务流支持。

Distributed Transaction Coordinator   协调跨多个数据库、消息队列、文件系统等资源管理器的事务。如果停止此服务，这些事务将会失败。如果禁用此服务，显式依赖此服务的其他服务将无法启动。


电商项目：很难实现分布式事务。。。【超卖现象】

