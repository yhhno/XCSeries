所说,全部记录下来.没追求的话,都只是完成. 必须有效率.
有逻辑的全过程:现在问题是我和他学,但最终是我要用,如果用我该如何运用的角度.来学习? 可以不.不要变成为了学而学?
同样不是为了模仿，而是学习技巧，最好自己也能总结出技巧来。
目前仅仅是模仿,不仅仅是全盘接受,做到心中有概念,它也是有错的,翻译有问题?
最终还是要自己来做,来试, 要慢慢从被动吸收,到主动吸收转换.

效率要提升起来,不然时间太慢了. 找找哪里费时间了.
记录(有时还会重新看)+看手机,看新闻,其实看的时候很投入可以节省时间.



此模型,一连串逻辑上的运用的意识还没有形成. 不仅仅单个点, 要面对的是一大坨问题呢?
0.心中有数(整体上的前因后果,大体的脉络,或者概念上的认识,作用(不能学完了不知道能干啥),),掌握主动,
	   1.有逻辑=>不断逻辑分析然后持续化解遇到卡壳问题
	   2.有技巧=>范围,目标,关注点,关键点,注意力集中,排除干扰因素,拒绝深渊(缺知识点,),先搞定不懂的基础知识点,先搞清功能流程,先搞清功能作用,
	   3.有效率=> 过程中,针对不断出现的情况,运用上面的方式,不断破击,不断改进.
	   4.其他的都是反面案例,不可取.=>目前不是时刻都处在正确的状态,所以要试试调整. =>直至成为习惯
	   5.有逻辑的,做到心中有概念.


一： replica set   【副本集】  看到此处有疑惑?  =>注意力不集中
replica set的特性: 也就是说副本集 比简单的master-slave更强大,强大在哪里呢?
1. master 和 slave 是复制分发关系，还有通信关系  通信关系指啥?

2. slave 和slave 之间也是有联系的。。。 如何联系? 联系了就是 p2p?


p2p 模式。。 啥是p2p呢?


这里的master 是由 replica set 集合选举出来的。。。 CAP概念。。 啥是cap?


zookeeper，redis 都是采用这种投票的机制来选举 master 从众多的slave之间。。。


mongodb建议我们用 replica set 来代替 master-slave。。。
因为:普通的master-slave 是没有选举关系，slave和slave之间并没有通信。。。 slave只是根据自己的source集合,同步主的数据就完了,没有其他的


arbiter(仲裁者)  secondary(备)  此时的关注点应该是大概是啥意思就可以了,这样可以流程走下去. 过分去深究就会发生关注点分离.错错错..


前者：不保存数据。。。             voted

后者：他是同步primary 的 data。。。 voted

整体上心中有概念? 不然搞个屁? 心里都没数?
二：搭建


有逻辑的走一遍,做到心中有概念?
1. 给集群取一个name。。。 在配置文件中设置


2. 集群的config配置。。。
   
   rs=> replica set .... 实例的集合


3. 可以再添加一个arbiter。。。




//1. 初始化集群
rs.initiate()

//2. 查看集群的配置
rs.conf()

//3. 像集群中添加members
rs.add("192.168.161.138:27001")
rs.add("192.168.161.138:27002")

rs.status()

rs.addArb("192.168.161.138:27003")   



/* 1 */
{
    "set" : "ctrip",
    "date" : ISODate("2016-07-26T22:13:11.565+08:00"),
    "myState" : 1,
    "term" : NumberLong(1),
    "heartbeatIntervalMillis" : NumberLong(2000),
    "members" : [ 
        {
            "_id" : 0,
            "name" : "192.168.161.138:27000",
            "health" : 1.0,
            "state" : 1,
            "stateStr" : "PRIMARY",
            "uptime" : 376,
            "optime" : {
                "ts" : Timestamp(6311636496545742, 1),
                "t" : NumberLong(1)
            },
            "optimeDate" : ISODate("2016-07-26T22:13:08.000+08:00"),
            "electionTime" : Timestamp(6311635401329082, 1),
            "electionDate" : ISODate("2016-07-26T22:08:53.000+08:00"),
            "configVersion" : 4,
            "self" : true
        }, 
        {
            "_id" : 1,
            "name" : "192.168.161.138:27001",
            "health" : 1.0,
            "state" : 2,
            "stateStr" : "SECONDARY",
            "uptime" : 153,
            "optime" : {
                "ts" : Timestamp(6311636496545742, 1),
                "t" : NumberLong(1)
            },
            "optimeDate" : ISODate("2016-07-26T22:13:08.000+08:00"),
            "lastHeartbeat" : ISODate("2016-07-26T22:13:10.546+08:00"),
            "lastHeartbeatRecv" : ISODate("2016-07-26T22:13:08.557+08:00"),
            "pingMs" : NumberLong(0),
            "syncingTo" : "192.168.161.138:27000",
            "configVersion" : 4
        }, 
        {
            "_id" : 2,
            "name" : "192.168.161.138:27002",
            "health" : 1.0,
            "state" : 2,
            "stateStr" : "SECONDARY",
            "uptime" : 153,
            "optime" : {
                "ts" : Timestamp(6311636496545742, 1),
                "t" : NumberLong(1)
            },
            "optimeDate" : ISODate("2016-07-26T22:13:08.000+08:00"),
            "lastHeartbeat" : ISODate("2016-07-26T22:13:10.547+08:00"),
            "lastHeartbeatRecv" : ISODate("2016-07-26T22:13:08.550+08:00"),
            "pingMs" : NumberLong(0),
            "syncingTo" : "192.168.161.138:27000",
            "configVersion" : 4
        }, 
        {
            "_id" : 3,
            "name" : "192.168.161.138:27003",
            "health" : 1.0,
            "state" : 7,
            "stateStr" : "ARBITER",
            "uptime" : 1,
            "lastHeartbeat" : ISODate("2016-07-26T22:13:10.547+08:00"),
            "lastHeartbeatRecv" : ISODate("2016-07-26T22:13:08.562+08:00"),
            "pingMs" : NumberLong(0),
            "syncingTo" : "192.168.161.138:27000",
            "configVersion" : 4
        }
    ],
    "ok" : 1.0
}


这个也是我们项目中正在采用的。。。。

这句话的意思是 如何通过驱动连接集群.
C#版本的mongodb。。。。 在构造函数中直接追加一个“，”隔开的字符串就可以了。。。


将风险降低到最少。。。。避免Mongodb挂了,影像服务.   主挂了后,重新选出主,需要一定的时间.


1.副本集的特点 p2p  cap,仲裁者
2.副本集的工作机制, 是否有概念?
3.副本集的流程, 是否有概念?
4.副本集的配置 
    1,启动实例,配置文件中配置集群名称 
    2.集群实例化 
    3.此时可以查看集群的概况 
    4.再启动一个配置集群名的实例.
    5.通过命令,把实例添加到集群中,
    6也可以添加一个仲裁者.
6.先抓脉络,形成整体上和流程上的概念. 做到心中有数,(关注点要准确),,然后再深挖细节.



文档不要忘了看?

          评价:理解了就不难,关键怎样算理解了? 如何去理解呢? 这样理解的程度好不? 看着整体逻辑图,清清楚楚知道过程细节?
掌握的方法:有逻辑的分析,有逻辑的理解.
掌握的标准:是否心中有概念?什么是心中有概念? 前因后果,有逻辑的推演整个过程.
掌握的技巧: 1.不要太关注,难或易,不然就陷入被动了,任何事都要主动.(想到任何事的相应的主动状态.)
           2.遇到新知识，大量不懂的概念？怎么办？ =》存在浏览式，完成任务？为什么呢？不懂的心理 驱使快速完成来安慰自己。
		   3.遇到理解卡壳，怎么办？
		   4.遇到不知所措，怎么办？
		   5.关注负面的东西,着眼于美好的东西.
是否复习：
