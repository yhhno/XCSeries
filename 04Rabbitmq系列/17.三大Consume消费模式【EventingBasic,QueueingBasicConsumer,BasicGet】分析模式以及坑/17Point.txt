最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?
问题4：逻辑过程缺失=>顺着他的文档，很容易缺失逻辑过程=》我学习就是学习他的方法，形成自己的方法论，这现象可不好

总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情                                                            =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图 和实现的细节 如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程
3.这只是学习能力，最多是理解，往后的应用能力呢，更别说设计能力了啦，=》非常欠缺=》那欠缺的是什么呢？

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，（此后就是细节）交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc,queuedeclare函数详解，queuedeclare函数参数arguments详解01，queuedeclare函数参数arguments详解02，basic也就是message01=》他怎么就可以一步一步推进呢？最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?
问题4：逻辑过程缺失=>顺着他的文档，很容易缺失逻辑过程=》我学习就是学习他的方法，形成自己的方法论，这现象可不好
问题2：新概念，消息的确实， =》正是这些新概念导致我的学习难以进行，=》要解决这个问题
问题0：对内存，磁盘，网络io都没什么概念，没有把他们当做评判的标准
 问题4：我们当时听的时候，稀里糊涂的，越听越不明白，听完还是一团浆糊，不知道是啥，=》缺少逻辑过程，就是queue怎么向consumer推数据，以及consumer如何消费数据的？=》正是因为越听越不明白，导致情绪低落，又导致更听不明白，此时又不能调整情绪。=》导致学时学不到东西，往后推进，困难重重，心里倍感沮丧。

总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情 （1，顺利时，2.遇到困难时）                               =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图 和实现的细节 如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程
3.这只是学习能力，最多是理解，往后的应用能力呢，更别说设计能力了啦，=》非常欠缺=》那欠缺的是什么呢？

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，（此后就是细节）交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc,queuedeclare函数详解，queuedeclare函数参数arguments详解01，queuedeclare函数参数arguments详解02，basic也就是message01，basic也就是message02，三大消费模式分析，=》他怎么就可以一步一步推进呢？


 问题1：分类
 问题3：逻辑过程有问题，不是一次逻辑过程
 问题2：老技巧
 问题4：我们当时听的时候，稀里糊涂的，越听越不明白，听完还是一团浆糊，不知道是啥，=》缺少逻辑过程，就是queue怎么向consumer推数据，以及consumer如何消费数据的？=》正是因为越听越不明白，导致情绪低落，又导致更听不明白，此时又不能调整情绪。=》导致学时学不到东西，往后推进，困难重重，心里倍感沮丧。
 问题5：遇到代码有更新时，不同时，不要慌，不要沮丧。=》确保情绪，确保主方向，确保逻辑过程
 问题6：主问题是 一股脑的打过来，那不要一次来太多可以不可以，少点可以吗？

大家好上节课，给大家讲了message的持久化和lazyqueue的问题
 这节课来讲consumer这点
 在之前的课程中，consumer已经讲得非常非常多了。
 问题1：分类
1. 短链接：basicget  独自主动去获取message。。。 也就是request 的方式去获取，也就是断开式。。。
这节课我们主要和大家讲长连接有哪些坑
2. 长连接：eventbasicconsumer。。。     【订阅式】
           queuebasicconsumer。。。
问题3：逻辑过程有问题，不是一次逻辑过程
订阅式有什么不好的地方呢
问题2：老技巧
我们可以来画张图
问题4：我们当时听的时候，稀里糊涂的，越听越不明白，听完还是一团浆糊，不知道是啥，=》缺少逻辑过程，就是queue怎么向consumer推数据，以及consumer如何消费数据的？=》正是因为越听越不明白，导致情绪低落，又导致更听不明白，此时又不能调整情绪。=》导致学时学不到东西，往后推进，困难重重，心里倍感沮丧。
有一个queue，有一个cosumer，如果是订阅式的，也就是说你在这个connection上面 里面有一个channel，
这个大家一定要知道， 我一直强调这个connection和channel是什么意思？
比如这个管道叫connection，这个connection下面可能有很多channel，所以说它是一个逻辑上的概念，
所以说我们在connection中创建很多很多的channel，是没有问题的额，因为他的代价非常非常小，一个线程可以用一个channel，
ok，直连式有一个什么样的影响呢？也就是是说我们这个队列中有多少个数据，就是全部打到你这个consumer中，不管你有没有被消费掉，，所以说它是一股脑的全部打过去，，也就是所有的东西都是通过connection打给你，我不管有多少，比如说有100w
那我这个100w全部给你，这时候就造成我们这个consumer，负载过大，对不对，
大家要想清楚了，这种情况是不是会造成我们的consumer负载过大，
比如说有100w，100w会全部打到这个consumer中，也就说queue中，当时是全部没有数据了，你可以认为是没有数据了，全部打到consumer中，这consumer何时何月才能执行完呢，而且的话，如果你不开启这个确认机制，一旦consumer挂了，导致全部的消息丢失，
我们可以给大家演示下这种问题，
给队列推100w数据
问题5：遇到代码有更新时，不同时，不要慌，不要沮丧。=》确保情绪，确保主方向，确保逻辑过程
第1个问题. eventbasicconsumer + noack.... 采用直联+不确认  这是会有什么问题？ 不确认，就是说我把数据给你就不管了额， 一点都不安全
假设consumer端处理一条数据需要耗费 1s钟。。。。毕竟你是业务处理1s算是很快的
我们来看看有什么后果呢？
我们发现消息很快的被处理了，因为输出了很多， => 他为什么会输出很多呢？反而是输出个消费完成反而不是一下子就输出很多
我们发现远远超过我们的处理限制，这么多的消息全部推过来了，，z
这时我们的内存是暴涨的，
如果说你message内容特别大，占有内存更大
也就是说此时有无数条消息推过来，
一次打了1w多条，对不对，
难道我们的处理速度有这么快吗？
按照正常的处理逻辑是1s处理一个呀，对不对
此时queue中没有数据了额，
但consumer仍在处理数据，
说明数据没有处理完，但是已经从queue全部传到了consumer中，所以内存会变大，此时所有的未处理完的message都在consumer的内存中，一旦挂了，message都丢失。
这不行，按照逻辑，没有处理完的数据，还应该回到queue中，

或者我们修改下，、塞入的数据很大
consumer用exe程序执行
此时插入了2660多个message，都是大数据
按照正常的逻辑，我们需要2600多秒才能处理完，
其实不是这么处理的额
启动consumer
发现一下子输出很多，不是1s一个
发现内存变大，此时如果message特别多，内存很可能会挂掉
这个风险是非常大的，弄不好就把consumer搞挂了
此时queue中没有message了，全部传到了consumer中，但是consumer此时肯定没有处理完，数据都是内存上，有很大的风险，consumer处理压力也大a
这个问题是非常严重的，搞不好数据全部丢失
针对这种问题，他也提供了几种方式

方式《1》 确认机制。。。   确认机制，他能带来什么效果呢，不管你是否确不确认，消息都会一股脑全部打入到你的consumer中去。。。也就是到你这个consumer内存中，会导致内存暴涨，导致consumer挂掉，虽然说你的message还在，但是会对consumer这个程序造成极大的不稳定，
此时再塞入一些数据 
在启动
数据还是一股脑打过来，
但是consumer还是处理不过来，虽然不会丢失message，
就算你加consumer也不能解决问题，你也不知道内存被占用多少
此时cosumer还不是不稳定，虽然解决了message丢失的问题，
consumer不稳定有没有解决办法，有就是方式2
方式《2》 QOS  =》 服务质量。。。  【QOS + Ack】机制，解决这个问题。。。 
问题6：主问题是 一股脑的打过来，那不要一次来太多可以不可以，少点可以吗？
就是queue会一古脑的数据打过来， 堆积在consumer中，造成问题
但是
我希望是一条一条从broke中打过来。。。 我处理一条你在给一条
这时解决办法就是在channel设置好通道。。。 就是说之前你的这个管子很粗，一次通过很多，现在管子变小一次只能通过一个，如果我不确认你就不要给我，这样的话就是串行了，
此时每次queue向cosumer推一个message，consumer处理一个，确认一个，确认后，queue再推下一个，此时consumer内存不会暴涨

总结下
eventbasicconsumer :  noack=true， 直连  =》 会造成application内存暴涨 + 可能丢失数据【application挂了】

		      noack=false, 直连  =》 造成【application】可能会挂掉。。

		      noack + QOS  直连  =》  没问题。。。 【我们可以想象的】


Queuebasicconsumer： 死循环的模式。。。  不建议，事件更好


BasicGet:            类似获取redis中的操作模式是一样的。。。。有时我们会把redis作为轻量级的queue
就是一次次获取，一次就获取一个，也就是说他不存在我们事件模式的 内存压力 consumer挂了，数据丢失等问题
		       不利的地方，就是每次都会创建一个channel。。。。  【最安全 + 性能不算太差】

                  
有好处，必然有相应的代价。。。





一：consumer 

1. 短链接：basicget  独自去获取message。。。 request 的方式去获取，断开式。。。



2. 长连接：eventbasicconsumer。。。     【订阅式】

	   queuebasicconsumer。。。


1. eventbasicconsumer + noack....

       consumer端处理一条数据需要耗费 1s钟。。。。

  《1》 确认机制。。。   不管你是否却不确认，消息都会一股脑全部打入到你的consumer中去。。。

  《2》 QOS  =》 服务质量。。。  【QOS + Ack】机制，解决这个问题。。。 
		 我希望是一条一条从broke中打过来。。。
		 
                 解决办法就是在channel设置好通道。。。


eventbasicconsumer :  noack=true， 直连  =》 会造成application内存暴涨 + 可能丢失数据【application挂了】

		      noack=false, 直连  =》 造成【application】可能会挂掉。。

		      noack + QOS  直连  =》  没问题。。。 【我们可以想象的】


Queuebasicconsumer： 死循环的模式。。。


BasicGet:            获取redis中的操作模式是一样的。。。。
		     不利的地方，就是每次都会创建一个channel。。。。  【最安全 + 性能不算太差】

                  
有好处，必然有相应的代价。。。
