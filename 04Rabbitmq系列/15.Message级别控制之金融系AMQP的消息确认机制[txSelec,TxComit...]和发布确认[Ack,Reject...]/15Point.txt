最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?
问题4：逻辑过程缺失=>顺着他的文档，很容易缺失逻辑过程=》我学习就是学习他的方法，形成自己的方法论，这现象可不好

总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情                                                            =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图 和实现的细节 如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程
3.这只是学习能力，最多是理解，往后的应用能力呢，更别说设计能力了啦，=》非常欠缺=》那欠缺的是什么呢？

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，（此后就是细节）交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc,queuedeclare函数详解，queuedeclare函数参数arguments详解01，queuedeclare函数参数arguments详解02，basic也就是message01=》他怎么就可以一步一步推进呢？

问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?

问题0：先理解
问题1：虽然是按照该它的文档开始的，但一定要有逻辑，不然以后怎么看呢，恐怕理解不了，而且顺的过程很容易缺失逻辑过程和主方向
问题2：新概念，消息的确实，
问题3：逻辑过程缺失， 不知道多次怎么来的，但没有去思考，
问题4:逻辑过程，手工确认与手工拒绝
问题4：逻辑过程缺失=>顺着他的文档，很容易缺失逻辑过程=》我学习就是学习他的方法，形成自己的方法论，这现象可不好
问题5：逻辑过程
问题7：主方向
问题8：评价


问题0：先理解
问题1：虽然是按照该它的文档开始的，但一定要有逻辑，不然以后怎么看呢，恐怕理解不了，而且顺的过程很容易缺失逻辑过程和主方向
大家好上节课，给大家讲完了queue的arguments
这节课我们就可以讲basic及basic的一些属性，一些方法
也就是消息 message 
问题2：新概念，消息的确实，
讲basic之前，我们首先要声明两个概念
一个叫做消费端的确认
一个叫做发布端的确认
首先我们要知道 AMQP协议：是一个金融级的消息队列协议。。。既然是金融级一定要确保消息万无一失，对不对， 要避免消息丢失，也就是不可以 可靠性不强。。

所以才有了确认=》需求的结果。有了解决方案
1. 消费端的确认
为了保证消费端消息百分之百收到，不允许有一条丢失，它采用两种方式
1.自动确认：  message出队列的时候就自动确认【也就是告诉broke，我们当前的消息已经被确认了】  用 basicget方法实现自动确认。。。 也就是autoack=ture
 //自动确认
//var result = channel.BasicGet("mytest15", true);//true  表示自动确认  false的话，虽然也会拿到message，但是queue的message不会被删除，确保消息一定是万无一失的，

2.手工确认：  message出队列之后，要应用程序自己去确认是否已经消费完毕。。。

如果consumer拿到message之后，没有手工确认，也就是 也就是autoack=false，这个时候message不会被丢失。。。 这也就确保消息一定是万无一失的， 否则在一个金融界，一个消息丢失是不堪设想的，比如一个转账丢失
此时就需要手工确认了
void BasicAck(ulong deliveryTag, bool multiple);手工确认函数 
确认一个或多个已递送的消息，，
一般来说我们手工确认只确认一条，很少情况下我们会确认多条
问题3：逻辑过程缺失， 不知道多次怎么来的，但没有去思考，
multiple: true =》   x< deliveryTag 的所有message都会被确认。。。。 一般是一条，那为什么会有多条呢？肯定是多次get了，但未确认了
问题4:逻辑过程，手工确认与手工拒绝
 既然我们可以手工确认，那我是不是可以手工拒绝呢                  

2.1手工拒绝： consumer拒绝服务器发送过来的消息。。。 例如只接受索引为偶数的message，
也就是接收到了message，然后拒绝，
拒绝之后有两个操作
非常类似于收快递
问题4：逻辑过程缺失=>顺着他的文档，很容易缺失逻辑过程=》我学习就是学习他的方法，形成自己的方法论，这现象可不好
《1》 直接扔了。。。 扔了也是一种确认，商家认为你收到了快递，也就是queue会删除这个message
《2》 给快递师傅。。。也就是退货 也就是把message返回给queue，那这个message可能被其他的consumer收到  也就是queue不会删除这个message
              
  //手工确认
            var result = channel.BasicGet("mytest15", false);//true  表示自动确认  false的话，虽然也会拿到message，但是queue的message不会被删除，确保消息一定是万无一失的，
            //其他的逻辑 也就是对message进行消费
            //channel.BasicAck(result.DeliveryTag, false);//手工确认

            channel.BasicReject(result.DeliveryTag, false);//单个手工拒绝，requeue为false为直接丢掉，，requeue为true时，把message给queue，queue重新发消息给consumer
            channel.BasicNack(result.DeliveryTag, true, false);//批量手工拒绝，requeue为false为直接丢掉，，requeue为true时，把message给queue，queue重新发消息给consumer
			
2.2重新递送：  【商家补发】 快递丢单。。。商家只能重新发一次。。。
   //重新投递，重新投递后，要重新获取
    channel.BasicRecover(false);//requeue为false时，重新投递给本consumer，true时，由queue重新发送给consumer，不一定是本consumer
    result = channel.BasicGet("mytest15", false);//true  表示自动确认  false的话，虽然也会拿到message，但是queue的message不会被删除，确保消息一定是万无一失的，	
问题5：逻辑过程
  文档解释，没有代码注释看文档
basicRecover
AMQP.Basic.RecoverOk basicRecover(boolean requeue)
                           throws IOException
Ask the broker to resend unacknowledged messages. In 0-8 basic.recover is asynchronous; in 0-9-1 it is synchronous, and the new, deprecated method basic.recover_async is asynchronous.
Parameters:
requeue - If true, messages will be requeued and possibly delivered to a different consumer. If false, messages will be redelivered to the same consumer.
消费端的这三种手工确认和自动确认 已经解决了99%的场景
除了basicget还有发布订阅模式


            EventingBasicConsumer consumer = new EventingBasicConsumer(channel);
            //consumer.Received += Consumer_Received;
            consumer.Received += (sender, e) =>//匿名函数   e相当于restult，但是少了没有指定从哪个队列去获取数据
            {
                //获取msg
                var msg = Encoding.UTF8.GetString(e.Body);

                //只是我们此处的消费是把message输出，当然可以做其他操作。=》用脑子去想
                Console.WriteLine(string.Format("我对message：{0},进行了消费，消费方式其实输出到控制台，当然有其他的方式", msg));

                //或者其他的逻辑 也就是对message进行消费

                channel.BasicReject(e.DeliveryTag, false);//单个手工拒绝，requeue为false为直接丢掉，，requeue为true时，把message给queue，queue重新发消息给consumer
                channel.BasicNack(e.DeliveryTag, true, false);//批量手工拒绝，requeue为false为直接丢掉，，requeue为true时，把message给queue，queue重新发消息给consumer

                //重新投递，重新投递后，要重新获取
                channel.BasicRecover(false);//requeue为false时，重新投递给本consumer，true时，由queue重新发送给consumer，不一定是本consumer
                result1 = channel.BasicGet("mytest15", false);//true  表示自动确认  false的话，虽然也会拿到message，但是queue的message不会被删除，确保消息

            };



我们来演示下，也就是看 Basic提供了那些方法来做到这些事情。


        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.149",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection 
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            BasicGetResult result = channel.BasicGet("mytest", false);

            //doing....

            channel.BasicRecover(true);

            result = channel.BasicGet("mytest", false);

            //直接扔了
            //channel.BasicReject(result.DeliveryTag, true);

            //channel.BasicNack()




            //手工确认
            //channel.BasicAck(result.DeliveryTag, false);

            //EventingBasicConsumer consumer = new EventingBasicConsumer(channel);

            //consumer.Received += (sender, e) =>
            //{
            //    var msg = Encoding.UTF8.GetString(e.Body);

            //    Console.WriteLine(msg);

            //};

            //channel.BasicConsume("mytest", true, consumer);

            Console.WriteLine("consumer1 端启动完毕！！！");

            Console.Read();
        }


2. 发布端的确认  手工确认消息是否已经发送到了broke。。。。
发送端的确认有两种方式
   1confirm机制。。。

   2tx机制： 【事务控制】
问题7：主方向
 也就是说publish 送message到rabbitmq中，我们一定要知道，这个消息已经发送成功了。。。。 也就是，rabbitmq一定要告诉publish，这条消息已经被确认收到。。。
 问题8：评价
这两种都是影响性能的，，，而且 confirm机制 <  tx机制【最耗费性能】可想而知，不管你是mysql或者sqlserver只要你用上事务，都是锁表额或者锁库  也就是说万不得已不要用，用就会伤害性能的额，

发布端使用起来还是非常简单的额，
 
            //发布确认
            channel.ConfirmSelect();

            for (int i = 0; i < 10; i++)
            {
                channel.BasicPublish(string.Empty, "mytest", null, Encoding.UTF8.GetBytes(string.Format("{0} 你好", i)));
            }

            var isallpublished = channel.WaitForConfirms();


try
{
    //发布确认。tx机制
    channel.TxSelect();
    for (int i = 0; i < 100; i++)
    {

        var msg = Encoding.UTF8.GetBytes(string.Format("{0}+{1}", i, "你好")); //因为我们要生成byte数组

        //str3 = i % 2 == 0 ? str1 : str2;

        //以上的四步算是连接rabbitmq，后面的步骤是具体操作  =》有这个认识是，心中有个架构图
        //第五步：发布消息   发布消息都用basic前缀=》先推个交换机，后续工作，交换机完成，如把消息推到指定的队列中
        //channel.BasicPublish(string.Empty, "mytest", null, msg);
        channel.BasicPublish(string.Empty, routingKey: string.Empty, basicProperties: null, body: msg);
    }

    channel.TxCommit();//如果不提交，操作没有执行
}
catch (Exception)
{

    channel.TxRollback();//失败了了回滚
}

这就是给大家讲的在消费端和发布端的机制，确保消息在发送和传输上万无一失，当然是以性能为代价的



一：Basic的一些属性，一些方法

AMQP协议：是一个金融级的消息队列协议。。。可靠性不强。。


1. 消费端的确认

	         自动确认：  message出队列的时候就自动确认【broke】  basicget。。。

		 手工确认：  message出队列之后，要应用程序自己去确认是否已经消费完毕。。。

                             如果consumer拿到message之后，没有手工确认，这个时候message不会被丢失。。。
			  
void BasicAck(ulong deliveryTag, bool multiple);

multiple: true =》   x< deliveryTag 的所有message都会被确认。。。。
                         

                  手工拒绝： consumer拒绝服务器发送过来的消息。。。

			     《1》 直接扔了。。。
 			     
                             《2》 给快递师傅。。。
                  
                  重新递送：  【商家补发】 快递丢单。。。商家只能重新发一次。。。
		
  
basicRecover
AMQP.Basic.RecoverOk basicRecover(boolean requeue)
                           throws IOException
Ask the broker to resend unacknowledged messages. In 0-8 basic.recover is asynchronous; in 0-9-1 it is synchronous, and the new, deprecated method basic.recover_async is asynchronous.
Parameters:
requeue - If true, messages will be requeued and possibly delivered to a different consumer. If false, messages will be redelivered to the same consumer.


   Basic提供了那些方法来做到这些事情。


        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.149",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection 
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            BasicGetResult result = channel.BasicGet("mytest", false);

            //doing....

            channel.BasicRecover(true);

            result = channel.BasicGet("mytest", false);

            //直接扔了
            //channel.BasicReject(result.DeliveryTag, true);

            //channel.BasicNack()




            //手工确认
            //channel.BasicAck(result.DeliveryTag, false);

            //EventingBasicConsumer consumer = new EventingBasicConsumer(channel);

            //consumer.Received += (sender, e) =>
            //{
            //    var msg = Encoding.UTF8.GetString(e.Body);

            //    Console.WriteLine(msg);
            //};

            //channel.BasicConsume("mytest", true, consumer);

            Console.WriteLine("consumer1 端启动完毕！！！");

            Console.Read();
        }


2. 发布端的确认  手工确认消息是否已经发送到了broke。。。。

   confirm机制。。。

   tx机制： 【事务控制】

	     publish 送message到rabbitmq中，我们一定要知道，这个消息已经发送成功了。。。。 也就是，rabbitmq
	     一定要告诉publish，这条消息已经被确认收到。。。

   影响性能的，，， confirm机制 <  tx机制【最耗费性能】


            //发布确认
            channel.ConfirmSelect();

            for (int i = 0; i < 10; i++)
            {
                channel.BasicPublish(string.Empty, "mytest", null, Encoding.UTF8.GetBytes(string.Format("{0} 你好", i)));
            }

            var isallpublished = channel.WaitForConfirms();