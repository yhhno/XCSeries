最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，



总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情                                                            =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图  如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc=》他怎么就可以一步一步推进呢？



问题0：此时有出现了仅仅是完成的心态
问题1:之前我理解rpc是什么概念呢？就是远程调用，把一些调用信息，发到远程电脑，然后由远程电脑调用，然后执行，然后返回信息，好像就是本地执行
问题1.1：这样的理解有什么用呢？还是稀里糊涂的，看似明白，其实没啥用，=>根本就不知道它解决了一个什么问题，也就没有主方向，，没有主方向，更不用谈学习，更不用太应用了=》那本地调用具体是什么？
问题1.2：那正确的了解是什么呢?
问题1.3.确定主方向，也就是本质，然后在去了解脉络，或者架构图，就是逻辑过程， 最后根据特性，去匹配业务，然后使用
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题3：老技巧，画个图
问题4：如果我心中没有个rpc的概念，那么如何去实现呢？=》抓紧去了解，深入理解计算机系统，
问题5：经验主义：一个过程就是从publish到consumer的一次执行，脑海深深烙下这个印象，不会去想其他的额，
问题5.1此时就不是一个过程了，此时exchange就不重要了，
问题5.2 这个过程我能不能设计或者总结出来，或者过程出来了，能不能用代码实现下呢？
问题6：至此，逻辑过程走了一遍，=》之前缺少这样的一个过程和结果，一看到就头脑发蒙，不知道干什么？不知道如何前进。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，



问题0：此时有出现了仅仅是完成的心态
上面四节课，已经把exchange已经讲完了，最后一个exchange是topic，对不对，
这节课我们就来讲rabbitmq官网教程的最后一个例子
问题1:之前我理解rpc是什么概念呢？就是远程调用，把一些调用信息，发到远程电脑，然后由远程电脑调用，然后执行，然后返回信息，好像就是本地执行
问题1.1：这样的理解有什么用呢？还是稀里糊涂的，看似明白，其实没啥用，=>根本就不知道它解决了一个什么问题，也就没有主方向，，没有主方向，更不用谈学习，更不用太应用了=》那本地调用具体是什么？
问题1.2：那正确的了解是什么呢?
问题1.3.确定主方向，也就是本质，然后在去了解脉络，或者架构图，就是逻辑过程， 最后根据特性，去匹配业务，然后使用
最后一个例子，它讲到了什么，讲到了一个rpc
那rpc的全名，大家应该也清楚，叫做什么呢，远程程序调用，或者远程过程调用
ok，rpc有哪些呢?
比如说我们的web站点 或者说web访问， 他都是rpc这种模式，对不对，
包括一些默认的wcf绑定 对不对，都是rpc模式  有nettcpbinding，basichttpbinding
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
从我们传统的意识上来说的话，消息队列的本质是干嘛的，消息队列的本质就是将我们这些rpc的应用异步化，对不对，
那你此时有个rpc的例子，是不是回到了老路上，
就发生了一个什么事情，就是将异构系统或者异构流程同步化，
本事我们用rabbitmq的话，就是将同步做成异步，对不对
那现在我们又要把异步做成同步， 这个怎么做呢？
当然我们基于这个rabbitmq会用到这个rpc这种模型
ok，这个该怎么实现呢？
我们来了解下吧
看下文档
问题3：老技巧，画个图
可能看文档，看的不是很清楚，我们来画个图吧，看看如何将异步流程同步化
问题4：如果我心中没有个rpc的概念，那么如何去实现呢？=》抓紧去了解，深入理解计算机系统，
它的实现原理就是用两个队列来实现，我们来画一张图，来解释下，
首先毫不疑问，有client 有server
问题5：经验主义：一个过程就是从publish到consumer的一次执行，脑海深深烙下这个印象，不会去想其他的额，
问题5.1此时就不是一个过程了，此时exchange就不重要了，
问题5.2 这个过程我能不能设计或者总结出来，或者过程出来了，能不能用代码实现下呢？
不同的是，client和server 既是consumer又是publish
然后有一个叫做rpc_queue，对不对，
然后还有一个guid_queue，
过程是client端，首先有个一个publish程序，定义一个guid_queue，发布一个message，message进入exchange（默认的exchange），然后exchange要把message转发给rpc_queue，
此时client还有一个consumer程序，一直监控着guid_queue。也就是说client发完message后，就一直监控着guid_message队列，因为这个guid_queue是client自己创建的，
这message里面的内容是两点 一个是我们的replyqueuename就是guid_name, 对不对  第二点就是correlation_id 生成一个guid，也就是一个动态创建的一个队列
这两点是放到我们的message里面去
然后，message进入了rpc_queue里面去，
然后server端  server既是consumer又是publish
此时我们的server有个程序，专门的监控rpc_queue
当messag进入到rpc_queue中时，就已经被此时正在监控的server的consumer程序消费，
当server端的consumer拿到了message后， 是不是就要进行处理了，也就是消费，
消费完之后，生成call_message，由server端的publish发布到，message中replyqueuename的队列上
此时client端的consumer正在监控guid_queue，会获得这个call_message，然后消费 也就是process
大概的流程就是这样，
ok，我们重新再梳理一遍，然后coding
问题6：至此，逻辑过程走了一遍，=》之前缺少这样的一个过程和结果，一看到就头脑发蒙，不知道干什么？不知道如何前进。
还是有点小复杂的，整体的流程就是这样的，


问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
我们的c#驱动有这个实现 这么个模型
simpleRPCclient
simpleRPCserver
我们利用两个模型来coding下

client端代码
  ConnectionFactory connectionFactory = new ConnectionFactory
            {
                HostName = "127.0.0.1",
                UserName = "qqqqqq",
                Password = "qqqqqq",
                //其他的设置，用默认的，此处不设置，
            };
            //第一步：创建connection
            var connection = connectionFactory.CreateConnection();
            //第二步：创建一个channel
            var channel = connection.CreateModel();


            SimpleRpcClient client = new SimpleRpcClient(channel, string.Empty, "direct", "rpc_queue");
           var result= client.Call(Encoding.UTF8.GetBytes("hello world"));
            Console.WriteLine(Encoding.UTF8.GetString(result));


            Console.Read();//拦住这个进程。
            //为啥不释放，释放了ui中就看不到了
            //using。。。。
            //channel.Dispose();
            //connection.Dispose();


server端代码
   ConnectionFactory connectionFactory = new ConnectionFactory
            {
                HostName = "127.0.0.1",
                UserName = "qqqqqq",
                Password = "qqqqqq",
                //其他的设置，用默认的，此处不设置，
            };

            //第一步：创建connection
            var connection = connectionFactory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            channel.QueueDeclare("rpc_queue", true, false, false, null);

            Subscription subscription = new Subscription(channel, "rpc_queue");
            MySimpleRpcServer server = new MySimpleRpcServer(subscription);
            Console.WriteLine("server端启动完成！！！");
            server.MainLoop();


            Console.Read();//把进程拦住。



一：RPC： Remote procedure call implementation


web站点。web访问

默认的wcf绑定，nettcpbinding, basichttpbinding。。。


异步流程 =》 同步化。。。


实现方式： 用两个队列实现




SimpleRpcClient



SimpleRpcServer
