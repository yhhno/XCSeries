缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题


问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅=》他怎么就可以一步一步推进呢？


问题0：总结上节课，那上节课讲了啥
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程
问题1：又画个图。  多播是什么？ 广播呢，
问题2：我潜意识就是在一个地方处理所有的东西，是不对的，
问题3：业务需求的分析和特性的结合，是个大问题。如同时发送短信和邮件，如下订单两条路
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题4:这个应该是利用了queue给consumer自动发消息的机制，不是完整的一套从publish开始到consumer
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题5:官网有文档，有案例，理论加时间=更好的理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，
问题7：对比一下，理解更好，
问题7.1，当时讲到direct的时候，说到exchange与queue的关系是这样的 =.根据会这个exchange，到底是如何分发到我们的队列中=>这个才是正确的认识，=》现实中，我们可以先听到直联方式，是通过routingkey来转发到指定的queue中，因为我们之前没有这个概念，而这个概念先接触，所以很容易就会把这个先接触的，当做是全部，=》其实此时我们就确实了主方向，就是 根据会这个exchange，到底是如何分发到我们的队列中 这句话=》直联只是分发的一种




问题0：总结上节课，那上节课讲了啥
大家好，上两节课给大家介绍了direct的一些场景，对吧 包括routing和work queue 任务分发。
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程
这节课我们来讲第二个exchange叫做fanout
那fanout是怎么用呢？ 因为他是一种多播的现象
问题1：又画个图。  多播是什么？ 广播呢，
我们花一张图吧，其实他的应用场景也是相当多的额，
问题2：我潜意识就是在一个地方处理所有的东西，是不对的，
问题3：业务需求的分析和特性的结合，是个大问题。如同时发送短信和邮件，如下订单两条路
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish
比如说一个简单的场景:下订单的流程  如果订单提交，同时发送短信和邮件 d对吧=》初步理解是在一个地方，处理两个事情，联想多播是一个接一个处理，=》错误的，首先交换是和queue绑定的，也就是message到了exchange，exchange在到queue，但不仅仅是一对一的关系，=》结合fanout是扇出，意思是像扇子一样出去，也就是一对多=》综上，情况是，message到了exchage后，然后扇出到和exchange绑定的queue，（类似于广播）每个队列都收到message，然后不同的queue有不同的consumer消费，做不同的事情，如一个队列发邮件（edm），一个队列发短信（sms）。=》要扩展思维，不仅仅是在一个程序里处理所有东西。

问题4:这个应该是利用了queue给consumer自动发消息的机制，不是完整的一套从publish开始到consumer
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer
还有一种也就是我们的一个客户端软件，可以从窗口右下角弹出消息，那这个弹出消息的话， 我们怎么做呢？ 普通的做法呢，是要轮询，对不对，那其实我们也可以用 这个绑定，我们在cs中绑定队列，或者绑定这个fanout exchange，这时候服务器有消息的话，可以及时推送，对不对， 那是不是这样的一个道理， 这样就解决了我们一个轮询的问题？=》不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer

还有什么样的应用场景呢
比如我们项目中的客户关怀和千人千面
这个是什么意思呢
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
也就是说淘宝推了一个订单来了，这时候我们要做两件事情，
第一件事情就是客户关怀，那客户关怀包括哪些呢？比如说催付，付款后提醒，发货提醒，签收提醒，等等，这是一条路
那第二条路呢，是到你用户下单的时候，我们不光可以催付，还有给用户关联推荐，这也是一种非常好的手段 比如说给用户推荐热门产品，以邮件的形式，或者彩信或者短信三种方式给用户发送关联推荐
ok，这是两条路，  
如果说用户特别多，比如百雀羚。联合利华 用户特别多，那么用户特别多的话呢，大客户比较多，我们就要用非常大的服务器集群，去处理这些逻辑对吧， 主要是有两条路，就是两个队列，就是淘宝推了一个订单，到了exchage，exchange转发到两个队列，一个队列处理催付，一个队列处理关联推荐，当然处理程序是大集群。  这就是我们的第三个场景

给大家讲了三个场景，这也是非常非常有用的，
在rabbimq中的路由表也有所不同，他没有routingkey


接下来我们给大家演示下，
问题5:官网有文档，有案例，理论加时间=更好的理解
这其实也是官网的案例三  发布订阅，就是扇入扇出
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，
首先把之前的queue删除，当然最快的方式是格式化，命令行，=》没有想到包括新建的用户都没有了，删除的非常彻底，只想到了queue，=》思考的不周全

当前前四步是不可少的，即使连接rabbitmq和设置队列等一些信息
问题7：对比一下，理解更好，
问题7.1，当时讲到direct的时候，说到exchange与queue的关系是这样的 =.根据会这个exchange，到底是如何分发到我们的队列中=>这个才是正确的认识，=》现实中，我们可以先听到直联方式，是通过routingkey来转发到指定的queue中，因为我们之前没有这个概念，而这个概念先接触，所以很容易就会把这个先接触的，当做是全部，=》其实此时我们就确实了主方向，就是 根据会这个exchange，到底是如何分发到我们的队列中 这句话=》直联只是分发的一种
直联与fanout区别，两个都是需要绑定exchange的，直联是绑定exchange中的某些特指的queue，如何特指加routingkey，而fanout是指绑定exchange的所有queue

publish代码

  ConnectionFactory connectionFactory = new ConnectionFactory
            {
                HostName = "127.0.0.1",
                UserName = "qqqqqq",
                Password = "qqqqqq",
                //其他的设置，用默认的，此处不设置，
            };
            //第一步：创建connection
            var connection = connectionFactory.CreateConnection();
            //第二步：创建一个channel
            var channel = connection.CreateModel();
            //第三步：申明交换机【因为rabbitmq已经有了自定义的ampq default exchange】 我们当然也可以自定义交换机  也就是显式的指定自定义的交换机，非隐式指定默认的交换机  publish是直接把消息推给交换机的，但交换机有默认的，所以交换机可以不声明
            channel.ExchangeDeclare("myfanoutexchange", ExchangeType.Direct, true, false, null);//也就是说有个交换机对象，像direct只是个类型而已=>用脑子去想

            //第四步：创建一个队列(queue)
            channel.QueueDeclare("myfanoutqueue1", true, false, false, null);
            channel.QueueDeclare("myfanoutqueue2", true, false, false, null);


            //如果是自定义exchange的话，需要把queue绑定到自定义的exchange上，容易出错，但如果是隐式的话，这些工作由rabbitmq默认完成了。
            //也就是说在erlang的measia数据库中个，有一个路由表，有三个列 exchangename queuename routingkey ，bind就是向这张表插入一条数据，，供以后使用，
            //此需求，必须实现自定义exchange， 默认的无法实现
            //也说明了，自定义exchange，更灵活，可以实现更强大的功能
            //此处有个问题：队列 exchange的声明，相互间的binding，应该是在管理端去完成，在publish端完成这个逻辑的绑定是不是不符合常理，也可以定义在消费端=》说明了无论publish consumer不仅仅是做publish和消费的工作，还是管理rabbitmq。=》主方向
            //当然这些东西，能不在代码中实现，就不要在代码中实现
            //潜在的一个问题：不要例子这样写，就认为全部都是这样=》找准主方向
            //channel.QueueBind("log_else", "myexchange", "debug", null);//routingkey默认是队列名，那也可以自己定义=》可以自定义的这个特性，可以实现是什么功能呢
            //channel.QueueBind("log_else", "myexchange", "info", null);
            //channel.QueueBind("log_else", "myexchange", "warning", null);
            //channel.QueueBind("log_error", "myexchange", "error", null);//consumer定义的话可以忽略这个，但publish呢 =》理解有问题

            //////优化版本
            ////var attr = new string[]{ "debug", "info","warning" };
            ////for (int i = 0; i < attr.Length; i++)
            ////{
            ////    channel.QueueBind("log_error", "myexchange",attr[i], null);/routingkey默认是队列名，那也可以自己定义=》可以自定义的这个特性，可以实现是什么功能呢

            ////}
            ////channel.QueueBind("log_error", "myexchange", "error", null);//consumer定义的话可以忽略这个，但publish呢 =》理解有问题


            //理解为什么定义两个队列，但consumer的话，就单独定义，比较好，消费那个，就定义那个
            channel.QueueBind("myfanoutqueue1", "myfanoutexchange", string.Empty, null);//要理解为什么没有routingkey
            channel.QueueBind("myfanoutqueue2", "myfanoutexchange", string.Empty, null);//要理解为什么没有routingkey


            for (int i = 0; i < 100; i++)
            {

                var msg = Encoding.UTF8.GetBytes(string.Format("{0}+{1}", i, "你好")); //因为我们要生成byte数组

                var level = i % 13 == 0 ? "info" : "error";

                //以上的四步算是连接rabbitmq，后面的步骤是具体操作  =》有这个认识是，心中有个架构图
                //第五步：发布消息   发布消息都用basic前缀=》先推个交换机，后续工作，交换机完成，如把消息推到指定的队列中
                //channel.BasicPublish(string.Empty, "mytest", null, msg);
                channel.BasicPublish("myfanoutexchange", routingKey: string.Empty, basicProperties: null, body: msg);
            }


            Console.Read();//拦住这个进程。
            //为啥不释放，释放了ui中就看不到了
            //using。。。。
            //channel.Dispose();
            //connection.Dispose();

consumer代码

     ConnectionFactory connectionFactory = new ConnectionFactory
            {
                HostName = "127.0.0.1",
                UserName = "qqqqqq",
                Password = "qqqqqq",
                //其他的设置，用默认的，此处不设置，
            };

            //第一步：创建connection
            var connection = connectionFactory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            //第三步：申明交换机【因为rabbitmq已经有了自定义的ampq default exchange】  我们当然也可以自定义交换机  也就是显式的指定自定义的交换机，非隐式指定默认的交换机   consumer是直接读队列的，所以交换机可以不声明
            channel.ExchangeDeclare("myfanoutexchange", ExchangeType.Direct, true, false, null);//也就是说有个交换机对象，像direct只是个类型而已=>用脑子去想



            //以上的四步算是连接rabbitmq，后面的步骤是具体操作=》有这个认识是，心中有个架构图
            //第四步：声明一个队列(queue) 此处的队列如果不声明的话，可能会有个坑，=》consumer是直接读队列的，如果先运行consumer的话，如果没有指定的队列存在会出错的
            channel.QueueDeclare("myfanoutqueue1", true, false, false, null);
            channel.QueueDeclare("myfanoutqueue2", true, false, false, null);


            //如果是自定义exchange的话，需要把queue绑定到自定义的exchange上，容易出错，但如果是隐式的话，这些工作由rabbitmq默认完成了。
            //也就是说在erlang的measia数据库中个，有一个路由表，有三个列 exchangename queuename routingkey ，bind就是向这张表插入一条数据，，供以后使用，
            //此需求，必须实现自定义exchange， 默认的无法实现
            //也说明了，自定义exchange，更灵活，可以实现更强大的功能
            //此处有个问题：队列 exchange的声明，相互间的binding，应该是在管理端去完成，在publish端完成这个逻辑的绑定是不是不符合常理，也可以定义在消费端=》说明了无论publish consumer不仅仅是做publish和消费的工作，还是管理rabbitmq。=》主方向
            //当然这些东西，能不在代码中实现，就不要在代码中实现
            //潜在的一个问题：不要例子这样写，就认为全部都是这样=》找准主方向
            //channel.QueueBind("log_else", "myexchange", "debug", null);//routingkey默认是队列名，那也可以自己定义=》可以自定义的这个特性，可以实现是什么功能呢
            //channel.QueueBind("log_else", "myexchange", "info", null);
            //channel.QueueBind("log_else", "myexchange", "warning", null);
            //channel.QueueBind("log_error", "myexchange", "error", null);//一个consumer只消费一个queue，所以不关error=》当时我还想着如何在一个地方处理不同的情况呢？=》分析不清楚，=》逻辑过程没走，经验主义=>之前想的是一个consumer只处理一个queue，但此时只是定义，不是处理queue呀，所以说可以全部定义的，当然也可以在两个处理queue中分别去定义，绑定

            //////优化版本
            ////var attr = new string[]{ "debug", "info","warning" };
            ////for (int i = 0; i < attr.Length; i++)
            ////{
            ////    channel.QueueBind("log_error", "myexchange",attr[i], null);/routingkey默认是队列名，那也可以自己定义=》可以自定义的这个特性，可以实现是什么功能呢

            ////}
            ////channel.QueueBind("log_error", "myexchange", "error", null);//一个consumer只消费一个queue，所以不关error=》理解有问题

            //理解为什么定义两个队列，但consumer的话，就单独定义，比较好，消费那个，就定义那个，如此处consumer1消费myfanoutqueue1，就只定义myfanoutqueue1.
            channel.QueueBind("myfanoutqueue1", "myfanoutexchange", string.Empty, null);//要理解为什么没有routingkey
            channel.QueueBind("myfanoutqueue2", "myfanoutexchange", string.Empty, null);//要理解为什么没有routingkey


            //主动获取
            //var result = channel.BasicGet("mytest", true);
            //var msg = Encoding.UTF8.GetString(result.Body);//result中有好多东西，相当于message的存储，

            EventingBasicConsumer consumer = new EventingBasicConsumer(channel);
            //consumer.Received += Consumer_Received;
            consumer.Received += (sender, e) =>//匿名函数   e相当于restult，但是少了没有指定从哪个队列去获取数据
            {
                //获取msg
                var msg = Encoding.UTF8.GetString(e.Body);

                //只是我们此处的消费是把message输出，当然可以做其他操作。=》用脑子去想
                Console.WriteLine(string.Format("我对message：{0},进行了消费，消费方式其实输出到控制台，当然有其他的方式", msg));
            };

            //定义了两个队列，单个consumer消费其中的一个队列，此时就不可以点击两次exe，充当两个consumer了。=>拒绝不加思考的就点击两次exe
            channel.BasicConsume("myfanoutqueue1", false, consumer);


            Console.WriteLine("consumer端启动完成！！！");
           Console.Read();//把进程拦住。


总结，publish发送一个message到exchange上，exchange如果是fanout的话，会把消息转发到所有绑定到exchange的queue上，也就所有的队列都会收到一份message，然后queue自动转发给绑定的consumer，如果consumer是一个的话，全部消费，如果是多个的话，轮询消费，平均分摊
这个模式非常像发布订阅，发布一个消息，所有订阅的端，都会收到相同的消息，然后做个各自的处理逻辑

从整体上看，也是下了一个订单，同时发邮件和短信，但实现手段完全不一样





一：exchange 【fanout】 多播的现象

1：应用场景相当多

《1》 下订单流程： 如果订单提交，同时发送短信和邮件。。。

《2》  cs软件弹出消息，普通情况下，我们是轮询的方式，我们在cs中绑定fanout exchange，这时候服务器             有消息的话，可以及时推送。。。。


《3》 客户关怀 和 千人千面

      taobao =>  【催付，付款后提醒，发货提醒，签收提醒 。。。。】 
 
             =>  【给用户关联推荐】 【彩信 和 邮件，短信 给我们发送关联推荐】




