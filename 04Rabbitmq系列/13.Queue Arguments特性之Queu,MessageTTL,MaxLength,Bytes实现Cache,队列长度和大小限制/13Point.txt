最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?


总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情                                                            =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图 和实现的细节 如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程
3.这只是学习能力，最多是理解，往后的应用能力呢，更别说设计能力了啦，=》非常欠缺=》那欠缺的是什么呢？

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc,queuedeclare函数详解，queuedeclare函数参数arguments详解01，=》他怎么就可以一步一步推进呢？

问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?



问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?
上节课讲了queue的durable（transient瞬间的），exclusive autodelete的参数
这节课我们来讲arguments参数
 第一点我们要知道，到底有哪些参数
 最简答的方式，我们看下ui
 共有七个参数，我们这节课来讲第一排
1 Message TTL   message的ttl分2种，ttl可以附加到queue和message上，也就是说一个是一个queue上的所有message，一个单独的message

          <1> Queue TTL   =》 Per-Queue Message TTL   【给一个queue的所有message限定一个时间】
							也就是说 它是Cache的一个效果。。。 比如说我们这个message只能放10天，多一个分钟都不行
          演示下，就是定义queue的时候，加个x-messagettl 字典值，然后8s后去看message是否存在
          <2> Message TTL =》 单独指定。【定制化的】 如何message和queue都设置了，以message为准，

                              IBasicProperties basicProperties,

其他信息: The AMQP operation was interrupted: AMQP close-reason, initiated by Peer, code=406, text="PRECONDITION_FAILED - inequivalent arg 'x-message-ttl' for queue 'mytest' in vhost '/': received none but current is the value '8000' of type 'signedint'", classId=50, methodId=10, cause=


        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.148",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            channel.QueueDeclare("mytest", false, false, false, new Dictionary<string, object>
            {
                //{"x-message-ttl", 1000*8 }   //queue中的所有message只能存活 8s。。。。
            });

            var properties = channel.CreateBasicProperties();
            properties.Expiration = "8000";


            channel.BasicPublish(string.Empty, "mytest", properties, Encoding.UTF8.GetBytes("你好"));

            Console.WriteLine("发布完成");

            Console.Read();
        }


2.Auto Expire  【自动删除】 和autodelete有点相关的，但是也是不相关的，
首先看官网文档是如何解释的
    《1》 当我们的queue在指定的时间内未被访问，就会被删除。。。也就是queuettl，当然这是在client端用代码设置，也可以在server端用policy设置

           访问是指consume，basicget，declare。等。。。这些条件在指定的时间内未被触发，我们就执行一个自动删除
文档解释
Expiry time can be set for a given queue by setting the x-expires argument to queue.declare,

触发条件
Unused means the queue has no consumers, the queue has not been redeclared, and basic.get has not been invoked for a duration of at least the expiration period

 演示下，就是定义queue的时候，加个x-expires 字典值，然后8s后去看
3. Max Length  限定队列的最大长度。。。 很简单比如limit =1000，最多是1000个，多一个都不行，=》理解有问题，是容量为1000个，多了一个，就从头部删除，而不是不能再添加
             文档解释
               How many (ready) messages a queue can contain before it starts to drop them from its head.

	       有点像redis,memcache。。。  LRU算法。。。也就是一个最大淘汰机制。。。。

               
演示下，就是定义queue的时候，加个x-max-length 字典值，然后发布15个，然后去看UI

4. Max Length Bytes 可想而知，限定队列的最大占用空间大小。。。比如说限定100m，多1k都不行，这个肯定是有使用场景的额，比如所磁盘只有100m，那你队列的大小肯定不能超过100m，超过了就会跑异常    【一般来说受制于内存，disk的大小限定】=》理解有问题

Total body size for ready messages a queue can contain before it starts to drop them from its head.

演示下，就是定义queue的时候，加个x-max-length-bytes 字典值，然后发布15b，然后去看UI



一：queue的arguments。。

1. 我们要知道到底有哪些参数属性。。。。

    《1》 Message TTL   

          <1> Queue TTL   =》 Per-Queue Message TTL   【给一个queue的所有message限定一个时间】
							Cache的一个效果。。。
 
          <2> Message TTL =》 单独指定。【定制化的】

                              IBasicProperties basicProperties,

其他信息: The AMQP operation was interrupted: AMQP close-reason, initiated by Peer, code=406, text="PRECONDITION_FAILED - inequivalent arg 'x-message-ttl' for queue 'mytest' in vhost '/': received none but current is the value '8000' of type 'signedint'", classId=50, methodId=10, cause=


        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.148",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            channel.QueueDeclare("mytest", false, false, false, new Dictionary<string, object>
            {
                //{"x-message-ttl", 1000*8 }   //queue中的所有message只能存活 8s。。。。
            });

            var properties = channel.CreateBasicProperties();
            properties.Expiration = "8000";


            channel.BasicPublish(string.Empty, "mytest", properties, Encoding.UTF8.GetBytes("你好"));

            Console.WriteLine("发布完成");

            Console.Read();
        }


2.Auto Expire  【自动删除】

    《1》 当我们的queue在指定的时间未被访问，就会被删除。。。

           consume，basicget，declare。。。。

Expiry time can be set for a given queue by setting the x-expires argument to queue.declare,

Unused means the queue has no consumers, the queue has not been redeclared, and basic.get has not been invoked for a duration of at least the expiration period


3. Max Length  限定队列的最大长度。。。 limit =1000

               How many (ready) messages a queue can contain before it starts to drop them from its head.

	       redis,memcache。。。  LRU算法。。。淘汰机制。。。。

               


4. Max Length Bytes 限定队列的最大占用空间大小。。。    【一般来说受制于内存，disk的大小限定】

Total body size for ready messages a queue can contain before it starts to drop them from its head.


