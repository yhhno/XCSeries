最重要的就是情绪，心态。它在开始，它贯穿了始终。它影响其他
缺少用脑子？=》如何纠正=》然后才是如何用脑子？
缺少逻辑过程，老是经验主义
一看到就怕？怕就不会进行下去了
如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案

终极问题：怎么样的状况，我自己去学东西时能有这效果呢？=》是不是缺少个对一个事情真正认识的例子，作为对比。或者说是一个渐变的过程，不是有一个招式就可以了=》也类似于，我到底要掌握什么样的能力，=》才能像优秀的人一样，才能做好每一件事呢。=》我们根本就没有逻辑过程这个意识。=》心中事先没有个预想的过程。=》=》消除一开始的慌，预想下，然后参考某个例子，去进行，也就是说要有某个模式，不可能我些什么都是从零开始的把=》我跟这个课程学习，就是按照作者的标准来行事，也就是学习一个高标准=》为什么跟他学好简单，自己学好难哦=》是不是模式有问题，=》这些根本就不够，预想了内容，但是我们能自我去实现这些内容吗？=》也就是不知道该怎么进行，有了逻辑过程的念头，那逻辑过程怎么推进，傻了眼=》一个小小的问题，就可能引起了卡壳。 太脆弱了
终极要求： 我不是靠着经验去做事的，去活的。  =》要用脑子去学，去做，去观察。=>如何用脑子呢？无比自信的，情绪高昂的 时刻分析情况，看到本质，预想方案
疑问： 为什么跟他学好简单，自己学好难哦=》是不是模式有问题，
问题：即便是跟着学习过一遍，还是独自没有仔细的走一遍逻辑过程 =》巨大的问题，当我课后自己去实践代码时，竟然毫无头绪不知道干什么？如何下手？=》什么原因造成的、

我怎么忘了之前是多么的优秀呢？
既然他没有很多新的概念，所以我就可以很快速的去完成，


问题6：这就是http协议vs 之前接触http协议是什么样子呢？http和request，根本就没关联起来，这说明了什么?=>当时的学习方式有问题，非常片面，不系统，导致只是简单了解下，对底层知识这种程度的了解 怎么能去学习更高层次的知识呢？
问题4：确实主方向，一次过程是这样的，一次publish是发布一个message，message是不是到了一个exchange，是，那一个exchange是不是把消息是不是发送给一个queue，不一定，那一个queue是不是只有一个consumer，不一定，其中，只有publish丢个消息，和设置好条件，其他的都是自动完成，=》就是用形成这样的认识，才透彻，当然是要在一个主方向的前提下了。=》当然实际过程是，多次publish=》
问题4.1要扩展思维，不仅仅是在一个程序里处理所有东西。
问题3:业务的分析，我怎么能分析出两条路呢。以及每条路是怎么走的呢？  这是个大学问？
问题1：新东西，应该是新机制，好奇他到底是什么呢？ 当时是和direct是不同的，不然怎么新的呢？=》先缺少脑子，再缺少逻辑过程=》逻辑过程必须有个模式，必须要总结出来=>这个是学习的逻辑过程
问题4.1不太理解， =》那就试着去理解，想想既然是解决了轮询，那轮询是干嘛的，是像服务器询问有消息不，而这是有消息有自动发送给你，就是queue发消息给你consumer=》虽然不太理解，但还是要尝试去理解的。=》找个方向点去理解
问题6：命令行实时在心中，逻辑过程不可少，也说明了对reset理解不够，仅仅是格式化，格式化后是什么效果，实际是不清楚的，=这个是学习的逻辑过程有问题
问题0：当时看到这里时，心里就充满了怕怕的，蒙的，不知道我自己要做什么了。
问题1：一开始看到这段英文肯定是心里怕怕的，要做的就是战胜这种怕怕，去找个主方向，走一下逻辑过程，把它给了解透透的
问题1.1 只有英文介绍，那英文阅读是不是很重要
问题1：到现在，我们才讲到消息队列的本质，不是应该在第一节课就讲到吗？也就是在此之前，就一直不知道为何而奔跑。
问题7： C#驱动有rpc的简单实现，=》我能不能从高层概念了解到最底层的逻辑过程？ 或者是能不能从很多信息中，总结出一个主方向，一个逻辑过程呢
问题8：如何封装也是一个技巧，=》当我知道最底层的过程，能不能写出来，=》写出来能不能封装下，
问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?


总结技巧=》或者是学习方法，就是要总结个模式，然后在去学习新东西时，如虎添翼。不然真的是讲到那个程度就学到那个程度。=>最终要形成各个思维导图，了然于胸，这样对特性了解清楚，才能结合业务，去实现业务呀
0.心态情绪信念热情                                                            =》最重要
0.切记经验主义，要不厌其烦的主方向+逻辑过程
1.学习一个技术的目的也就是本质，如消息队列的本质是将同步系统异步化               =》主方向
2.一个技术的脉络或者架构图 和实现的细节 如wcf的soa思想和binding的分类，和rabbitmq的架构图   =》逻辑过程
3.这只是学习能力，最多是理解，往后的应用能力呢，更别说设计能力了啦，=》非常欠缺=》那欠缺的是什么呢？

问题0：如果是我学些的话：看一篇文章，有实例的那种，也许会demo下，也许就收藏了，而且毫无感觉VS用脑子的，有感觉得进行：先概况和本质，再安装，再管理，再详解配置文件，连接rabbitmq，（此后就是细节）交换机机制direct之workqueue，交换机机制direct之routing，交换机机制fanout之发布订阅，交换机机制headers,交换机机制topic,rabbitmq层面实现rpc,queuedeclare函数详解，queuedeclare函数参数arguments详解01，queuedeclare函数参数arguments详解02=》他怎么就可以一步一步推进呢？

问题0:理解和知道如何实现，同样重要，应该先理解，后知道如何实现，如果都不知道怎么用？那谈什么实现呢?


问题1：新概念=》正是这些新概念导致我的学习难以进行，=》要解决这个问题
问题2：老技巧，画个图
问题3：数据结构缺失


大家好这节课给大家讲arguments后剩余其他的
问题1：新概念
何为Dead letter
之前讲到
       max-length就是queue长度限制。。。超过就删除头部 【mongodg 中的oplog】 就是一个固定集合。。他都是有一个固定应用场景的。也就是长度有限制

	    queue中的message过期时间。 过期时间到了就删除

	    basicreject...basicnack等等。。。消息确认拒绝以及不返回，两种拒绝方式 被拒绝的消息

	   这三种情况一般会drop这些message。。。
ok，上面讨论的都是默认的
有时我们不想这些消息，drop掉，而是走到另一个队列中，又或者是保存起来。。。
这是我们遇到一个场景


一： Dead letter exchange  
如果只设置Dead letter exchange 而不设置 Dead letter routing key 的话，message会重新进入默认的exchange

     有时候我们不希望message被drop掉，而是走到另一个队列中，又或者是保存起来。。。
	 如果你定义了这个Dead letter exchange argument，遇到message被删除的时候，它会直接把这个消息打到exchange中去

二： Dead letter routing key 

     打到exchange中去的时候，他的routingkey是什么，，
	  如果你定义了这个Dead letter routing key argument，遇到message被删除的时候，它会直接把这个消息打到exchange中去时候并指定routingkey
问题2：老技巧，画个图
针对这两种场景，画个图吧 方便大家去理解

和普通定义方式没什么两样。。。


用max-length 给大家做一个演示。。。

        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.149",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            channel.QueueDeclare("mytest", false, false, false, new Dictionary<string, object>
            {
                {"x-max-length",10 },
                {"x-dead-letter-exchange","mydead_exchange" },
                { "x-dead-letter-routing-key","mydead_queue"}
            });
            
            for (int i = 0; i < 11; i++)
            {
                channel.BasicPublish(string.Empty, "mytest", null, Encoding.UTF8.GetBytes(string.Format("你好 {0}", i)));
            }

            Console.WriteLine("发布完成");

            Console.Read();
        }


三： Maximum priority  
优先级队列其实在我们的实际开发中也是用的比较多的，因为有些消息的优先级非常非常高，所以我们要让它优先被consumer预知到。
问题3：数据结构缺失
     优先级加到队列上，就是一个优先级队列，，， 【在数据结构中我们是如何实现的呢？一般用堆，也就是所谓的大根堆，小根堆，当然我们使用数组和对象都能实现】
接下来我们看优先级怎么实现？

第一步1. 给队列贴上一个优先级的标签。。。   x-max-priority =10, 建议这个值不要设置的太大。。。  大的话肯定节点更多。。 redis中有了类似的sortset。。。

							 不管你用什么语言实现，都是一个tree结构。。。。

第二步2. 给message打上具体的优先级的value。。。  value<=10

   MSMQ的message级别一般也就4，5中。。。low/normal/high/higher//........ 包括windows线程的优先级也就三种

   我们通过“优先级”特性，，将一个queue 变成了 stack。。。。为啥呢，先进后出呗







何为Dead letter
之前讲到
       max-length: queue长度限制。。。 【mongodg oplog】 就是一个固定集合。。。

	    queue中的message过期时间。

	    basicreject...basicnack等等。。。

	   这三种情况一般会drop这些message。。。


一： Dead letter exchange 

     有时候我们不希望message被drop掉，而是走到另一个队列中，又或者是保存起来。。。


二： Dead letter routing key 

     打到exchange中去的时候，他的routingkey是什么，，


和普通定义方式没什么两样。。。


用max-length 给大家做一个演示。。。

        static void Main(string[] args)
        {
            ConnectionFactory factory = new ConnectionFactory()
            {
                HostName = "192.168.23.149",
                UserName = "datamip",
                Password = "datamip",
            };

            //第一步：创建connection
            var connection = factory.CreateConnection();

            //第二步：创建一个channel
            var channel = connection.CreateModel();

            channel.QueueDeclare("mytest", false, false, false, new Dictionary<string, object>
            {
                {"x-max-length",10 },
                {"x-dead-letter-exchange","mydead_exchange" },
                { "x-dead-letter-routing-key","mydead_queue"}
            });
            
            for (int i = 0; i < 11; i++)
            {
                channel.BasicPublish(string.Empty, "mytest", null, Encoding.UTF8.GetBytes(string.Format("你好 {0}", i)));
            }

            Console.WriteLine("发布完成");

            Console.Read();
        }


三： Maximum priority  

     优先级加到队列上，就是一个优先级队列，，， 【堆，大根堆，小根堆】

1. 给队列贴上一个优先级的标签。。。   x-max-priority =10, 这个值不要设置的太大。。。  节点更多。。 sortset。。。

							 不管你用什么语言实现，都是一个tree结构。。。。

2. 给message打上具体的优先级的value。。。  value<=10

   MSMQ的message级别一般也就4，5中。。。low/normal/high/higher//........

   我们通过“优先级”特性，，将一个queue 变成了 stack。。。。
