设计模式,也就是设计过程中的解决问题,设计的套路总结? 怎么去设计?怎么去解决? 这是个问题? 是个核心能力?  需要训练?  要有大前提? 要有环境?
思路一步一步都记下来.


设计模式: 前人总结的经验,毕竟是前人踩过的一些坑,从这些坑中得到一些经验,以文字的形式,总结下来.这些经验供我们后来着,思考,借鉴,怎么去化解一些问题.
GOF提供了23中设计模式,可以解决现实软件开发中,很多场景中一些问题的解决方案. 属于经验的东西,

一：设计模式的7大原则  原则是什么呢?  为什么要有原则呢?   有什么好处呢? 都是在设计的时候体现? 设计中尽量的体现. 尽量避免不好的设计?

1.依赖倒转原则  所有的设计模式都体现了 依赖倒转原则
如何理解依赖倒转? 不倒转是啥样的? 依赖如何理解? 依赖啥?
 不好:  依赖不倒转  Mytest mytest=new Mytest();... 硬编码

  好:  依赖倒转    依赖于抽象，依赖于接口。。 如何理解依赖于?  方便子类的切换

       ITest mytest=new Mytest(); 
  
  

2.单一职责   如何理解? 为什么要这么做呢?  如何体现?

  只做一件事情，不会做其他不相关，或者跨界的事情。。。

  public class User{
     Add();
     Modify();
     AddOrders();//这是不可以的
  }

public class Orders{

}

专业的人做专业的事情。。。  只做一件事,或只能与自己有关的事不跨界;


3.开闭原则 如何理解? 如何体现?

  开：可以添加，新增代码。

  闭：对修改代码。


理想情况下:我们做新功能，不希望对原有的代码进行修改。。。 【通俗易懂】


4.合成复用原则 如何理解?

  我们给一个类添加功能：【继承】，【关联】

  继承： 子类可以获取父类的状态和行为。非private。。

  关联： 可以获取另一个类的状态和行为
    
   Order order=new Order();
   order.user....xxxx....//Order类获取User类的功能

        public class Order{
          public User user=new User();        
        }

        public class User{
           protect 
        }
		关联: 除了获取,不可以修改  Order类和User类相互封装,相互独立,也就是说order类不能修改user类


        public class Order:User{    //获取Order的行为或状态。

        }
		继承:  除了获取,还可以修改 protected的属性,
		所以设计模式中不要滥用继承,有可能会出现风牛马不相及的情况(Order继承User)

		
设计模式中:   is-a 情况下使用继承    什么和什么是一个种类的
             has-a 情况下使用聚合。  什么和什么不是一个种类的   【桥接模式是合成复用原则的体现】



5.迪米特法则，又称最少知道原则（Demeter Principle）

  类与类之间保持相对独立(体现单一职责)，这样才能降低耦合。。。 但类与类之间避免不了相互通信的问题。也就是需要交互的

  比如: A <-> B     a和b之间发送消息

  但我绝对不希望在A中引用B，在B中引用A。。。怎么办? 针对这种通信问题? 一般怎么处理?   加中间件进去。  中间件有【redis,rabbitmq】  a和b通过中间件通讯,  在很多开源软件都有体现

  解决:A <- middlesoft  -> B    中间件作为消息的传递 实现解耦  【中介者模式体现迪米特法则 相当于中间件的作用】


6.接口隔离原则 什么意思呢? 如何理解?  如何理解隔离?

刚开始学: 知道接口是一种契约,先有接口再由实现类

 但有时会为了方便 将几个类中的方法都提取到一个接口中，形成一个大的接口。。。 然后让子类去继承这个大接口。
  
 但是 子类只需要继承自己需要的接口。。其他的用不到,所以不要把所有的东西都给我  【也就是最少化接口】

 举例:
  orders【订单系统】

  前台站点：  query

  网站后台：  CURD
  
  第三方分销商：query，add  

一般情况: 只定义一个大接口,给三个站点使用
        此时前台继承这个接口,拥有所有的方法,但它只需要 query方法,需要其他的.不要给我
public interface Iorder{
  Add(),
  Modify(),
  Query(),
  Remove();
}

更好: 一个接口拆成三个?
public interface IOrder1{ 前台
  Query（）
}

public interface IOrder2{ 分销商
  Add（）
  Query（）
}

public interface IOrder3{ 后台
  CURD
}



7.里氏替换原则 如何理解?  替换什么呢?  在哪里可以体现? 设计继承类的时候?  为什么要替换?

父类存在的地方，子类都可以替换，并且行为不发生改变。。。 如何理解?  如何理解地方? 如何理解行为不发生改变,   如何体现?

1. 人类可以上厕所(Action)

      人类

男人        女人

如何理解只要人类可以上厕所的地方,男人和女人都可以上  如何理解地方? 如何理解父类,子类?  如何理解行为不改变

2.         鸟 （Fly) Action

燕子 (Fly)      企鹅  (Fly) 企鹅不会飞.


违反了 “里氏替换原则”

生物学上的分类不见得在 面向对象中行得通。。。  【特例】  



1.设计模式是啥?  设计过程中的特定套路总结
2.7大原则是啥?   设计过程中通用的套路总结
3.依赖倒置原则
4.单一职责原则
5.开闭原则
6.合成复用原则
7.迪米特法则
8.接口隔离原则
9.里氏替换原则



0是什么状态? 怎么演绎? 1是什么状态? 过程遇到什么问题? 有什么样的解决方案?  VS 有什么方案? 解决什么问题?   在正常的流程的大前提下,去看问题, 关注点不能本末倒置.  脱离环境 咋理解呢?

