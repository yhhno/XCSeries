设计模式,也就是设计过程中的解决问题,设计的套路总结? 怎么去设计?怎么去解决? 这是个问题? 是个核心能力?  需要训练?  要有大前提? 要有环境?
思路一步一步都记下来.
1.正确分析问题思路:没有查看类图=> 类图是什么?=>一个cd文件=>1.附加个现成的cd文件=>不识别=>2.看是否能添加cd文件=>发现没有=>通过方式1和方式2 应该可以判断出是template缺失?=>添加即可====> 最终定位为template
2.错误的分析问题方式:流于表面的瞎百度, 根本没思考.就困在这里,毫无有用的瞎转悠=> 错误归错误,不要影响积极的情绪=====>最终定位为方式或思路错误,赶快调整.
3.最重要的是方式错误时和情绪时的调整. 也就是心理素质.
4.分析步骤:	类似于while?如何理解? while(true)  什么是true条件? 肯定不是console.writeline(). 那只能是movenext()=> while(movenext()){console.writeline(current).};    movenext如何实现的恩?  其实很简单了? 历史没有真相,只残存一个道理.. movenext的道理是什么?
5.有时关注点放错了,困在某个点,,有时是没深入分析,困在表面
6.概念一知半解,流程不深究没概念. 逻辑推理分析没形成习惯. 也没有正确的模型.
7.我从来不觉得我比别人差
8.进入状态比较慢, 
9.出了问题,,残存什么样的道理?  做啥动作? 为啥目的? 用啥材料? 用啥逻辑? 有啥方式?
10.怀疑一切,或者任何事我也可以做.
11.有点不认真,没有边学边思考,边推理. 效率不高,还返工,,,你有多成功,取决于你有多渴望成功.
12.目的是啥? 这就是此时的主体? 主体都搞不清楚? 容易困于某个点,此时的监控,感应通知等 ==>先找到主体,有个整体的认识,在去扣细节和辅助. 观察者
13.带着(目的是创建对象)的前提来看问题? 一切为了创建,  肯定有由创建过程. 也可以顺着目的,逻辑推理 每一步该怎么做?   建造者
14.抽象的概念描述不好理解,一定要结合实例 :一个复杂的对象(房子)由很多的子部件(黄沙，瓷砖，水泥，青砖)的组成，子部件(黄沙的品牌)是多变，但是子部件组成的流程确实不易变。 流程是啥呢?
15.和自己理解的备忘录模式,差的太多了,说明了什么? 分析有问题? 映射有问题? 理解也有问题? 逻辑推理有问题?==>这里不解决,也就没思路,,没思路搞个屁.
16.完整过程是怎样呢? 肯定要顺一遍.  不然咋交逻辑推理? 不能只关注一个点.  全过程.
17.我以为撤销是在执行后撤销,第一感觉是这样, 说明什么? 对事情根本没有本质的认识? 或者很多认识都是错的,还有其实内心是阻止自己深入的,觉得做不到? 也不觉得做不到有什么不好? 深入都没深入,更别谈什么能不能了.==>我能,必须前进.
18.容易懒惰,容易没激情,容易不积极,容易放弃,容易不调整.心态不乐观.容易没渴望
19.无师自通是个什么情况?
20.字典在容量比较小的情况下,也是很好的,但容量非常大的时候,也是内存抗不住的(为什么),也就是要借助redis===> 说明什么问题?  每次思考的都是理想情况下 和单独一个点.
21.不好维护  ===> 说明什么问题? 每次思考的都是单独一个点
22.过程是什么? 设计模式针对特定的问题, 是一个点,但问题在过程中.
23.以前存在一个问题, 啥啥都不知道,都不理解的情况下,没有该有的概念?没有该有的思维?没有该有的模型, 去看干巴巴的字,怎么可能去理解呢 去干好呢?比如:让一个乡下人去干金融,面对一大堆名词,死记硬背,硬理解, 然后去做事.


一：享元模式   过程是什么? 设计模式针对特定的问题, 是一个点,但问题在过程中.

1. 共享元数据的意思？？？  ok   如何实现呢?  如何共享? 怎样共享

 目的:  减少内存开销，避免在内存中实例化众多相似或者相同的实例。。。。为什么要减少内存开销呢?  与单例(避免高消耗的new)区别.


 大白话: 做了十次的new ,其实都是一个类，，如果我们把这个new缓存起来，下次new的时候还是取这个缓存。。。【节省了内存】 为什么节省了内存?

 你不能浪费内存,我们要做一个穷人.使用内存要省着用,不能你想怎么用就怎么用,用完之后,有个gc回收,这下就苦了gc,1000次同样的new, gc要累死了.同时还占用了内存

类似于:  类似于,但真实情况不是这样的. 说明下共享在实际开发中的应用了.
class Program
    {
        static void Main(string[] args)
        {
            Dictionary<int, Person> dic = new Dictionary<int, Person>();
            for (int i = 0; i < 10; i++)//10次new,内存中就有10个person的实例.,还不如第一次就缓存下来.
            {
                Person p = new Person();
                if (dic.ContainsKey(p.GetHashCode()))
                {
                    p = dic[p.GetHashCode()];
                }
                else
                {
                    dic.Add(p.GetHashCode(), p);//保存在内存中 如何理解?
                }


            }
        }
    }
    class Person
    {




2. .net中有很多这样的案例  都是享元模式 应用很广泛, 但存在一个问题, 以为缓存就是享元模式? 倾向接收是什么? 而不深究为什么?


string的驻留池 string是值类型中的引用类型.
 static void Main(string[] args)
        {
            string s1 = "你好";//你好是放在堆上的,也就是说值类型放在栈上的
            string s2 = "你好";
            var b = String.ReferenceEquals(s1, s2);
            Console.WriteLine(b);//true, 说明s1和s2执行同一个引用
        }

redis,db 的连接池 

线程池  而不是每次都是new thread。。。。

Task =》 寄托在线程池上的线程，，，而且是做包装的。
Task.Factory.StartNew()

3. Razor    asp.net mvc 做模板引擎 都是享元模式   razor是干嘛呢?

http://razorengine.codeplex.com/   


Razor:    模板(缓存) + 商品  =>   一封邮件


// RazorEngine.Templating.TemplateService
internal ITemplate GetTemplate(string template, Type modelType, string name)
{
	if (!string.IsNullOrEmpty(name) && this.templateCache.ContainsKey(name))//templateCache是个线程安全的集合? 听到线程安全就懵逼了吗? 笨笨笨
	{
		return this.templateCache[name];//肯定要缓存,没缓存怎么提高性能? 那提高性能有啥方式恩?
	}
	ITemplate template2 = this.CreateTemplate(template, modelType);
	if (!string.IsNullOrEmpty(name) && !this.templateCache.ContainsKey(name))//这个判断说明了什么?
	{
		this.templateCache.Add(name, template2);
	}
	return template2;
}


二：模型

享元模式 样例 步骤
1.定义一个抽象类FlyWeight,添加一个抽象方法Run
2.定义一个ConcreteFlyWeigth类和UnSharedConcreteFlyWeight类,并继承抽象类FlyWeight,并实现各自的Run方法
3.定义一个Factory类,添加CreateInstance方法,和用于缓存的 线程安全的字典CacheDic字段, 实现CreateInstance的逻辑
4.在main函数中调用,比较第一次使用,和后续使用有啥不一样.  我们得到了相同的实例, 但可变的,肯定要通过参数串进去,达到相似的实例/
5.模式涉及的是实例的共享, 1.首先有实例(FlyWeight),2.再有共享(Factory),3.再使用 Factory.CreateInstance 4.完整的过程.


可变和不可变参数。。。  如何理解? 不可变的参数我们得到了相同的实例,可变的参数通过Run函数传入, 达到相似的实例.



1.享元模式? 是啥? 相同或者相似的实例 共享问题?
如何共享? 减少内存开销.
2.过程.



   1. 0是什么状态? 怎么演绎? 1是什么状态? 过程遇到什么问题? 有什么样的解决方案?  VS 有什么方案? 解决什么问题?   在正常的流程的大前提下,去看问题, 关注点不能本末倒置.  脱离环境 咋理解呢?  目的是啥?
  2.如何演绎的? 第一步是啥?新需求? 如何执行新需求? 有什么问题? 对应有什么解决办法? 解决方法有没新名词? 解释新名词? 执行接下来的一步 ... 重复执行? 这需要细节?
  3.要搞清楚的东西:
		1.多调试,看看顺序执行,分支,跳转,循环等执行路径  多重分支,多级分支, 
		2.同步,异步执行路径  特别是异步没有wait时.
		3.锁执行路径
		为什么要弄清楚呢? 大体情况要了解,避免处于盲区,或者关注点错误.或者没有大前提.
4.如何理清脉络? 有哪些关键点? 如何做到这些关键点? 这些关键点是为了达到什么样的目的? 关键点如何串起来.? 也就是说小目的串起来,达到最终目的?做事是为了达到某些目的? 出了问题?也就是目的没达到,也就是做的事有问题. 先找到主体,有个整体的认识,在去扣细节和辅助.
5.避免,毫无目的,毫无主线,无前提,无脉络 . 毫无关键点 也没主动. 瞎转,当然心中没数了,生活中也是如此
6.分析是如何分析的呢? 从oo角度分析, 无非一些类,然后交互. 还有流程的
7.分解很重要.  如何分解呢?  映射其实就是分解? 设计算法也是分解? 但分解到底是啥呢?
8. 抽象? 如何抽象?
9.分析问题不够深入,不能猜想,不能逻辑推理,容易卡壳,特别是遇到新概念,不懂的名词,卡壳后不会调整,学习不够本质,不能活学活用,容易只记住案例,当遇到类似的时候,不能联想, 举一反三.===>缘由倾向于接收是什么? 而不去了解为什么?   等级不一样,肯定不能拿着低等级的知识,去做高等级的事情吧.
10.如何用oo的角度,来描述一个情景.
					1.有哪些元素 也就是类
					2.概念上的流程是什么? 也就是怎样的一个行为,接着一个行为?
					3.如何完成一个行为? 谁自己完成了什么? 还是谁对谁做了什么?
		案例:转配手机
		需求:给手机贴膜和安装挂件.
		分析:    //1.先有个手机       
				//2.再有配件
				//3.先装配贴膜
				//4.在装配挂件,注意:是将挂件装配到已经贴膜的手机上
				//5.显示下装配结构
		如何实现呢?  