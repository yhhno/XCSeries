所有的都要记录下来. 边学边记. 抛弃深渊. 状态要预热呀. 还是要有激情的. 关注点要正确的. 体现各种形式上的"主动" , 用脑子学习思考.
找出自己的不足?心理素质还是最关键的. 不要习以为常? 还是心中要有概念. 不懂的地方一定要深挖,深挖了就简单了.哈哈 
效率啊  理解能力有待加强, 理论变成大白话, 一眼看本质,看透的能力要加强(核心竞争力呀)
无论什么都是要有个模型的? 比如理解模型? 思考模型? 对比模型? 等等
理解不够透彻? 大概了解就完成了,没有深入有逻辑,全过程推演.
理解了大概? 在了解如何实现?  真正的了解大概(有大前提,基本流程,在扣关键点), 真正的如何去实现?=> 这是个全过程嘛,=>主动起来, 还是要主动起来.
万事不要沾上"懒"字? 遇到新的该咋办?
真正的了解大概(有大前提,基本流程,在扣关键点)+1
为啥觉得很简答呢?=>很简单=>很好玩=>很有趣



一：锁机制  锁是啥呢?  概念上是啥? 实质上是啥呢?

1. .net锁机制太多了   都有那些呢?

   时间锁，信号量，互斥锁，读写锁，互锁，易变构造

分类：

<1>  用户模式锁  【就是通过一些cpu指令或者相当于一个死循环】在达到thread等待和休眠  与thread有啥关系呢? 各自线程获取锁,来操作或者操作数据.

<2>  内核模式锁

                就是调用win32底层的代码，来实现thread的各种操作 例如:Thread.Sleep  调用底层的win32代码,来使线程休眠

<3>  混合锁

             用户模式 + 内核模式 【应用场景是最多的】  xxxslim


2. 为什么要用锁   1.对共享变量的操作? 2.同一时刻是能一个操作共享变量的特性?

   多个线程对一个“共享资源”进行操作的时候，容易出问题。。。 共享资源混乱。。。也就是说同一时刻,只有一个线程操作资源.  或者说同一时刻,只有一个线程进行某种操作.


3.用户模式锁
  
《1》易变结构：    volatile关键字  啥是易变结构?  实质上如何实现的
有个共享变量,有一个线程读，由一个线程写，在release的某种情况下，会有debug。。。,因为会把共享变量放到cpu缓存中,导致不能及时更新,而导致工作线程一直循环,不能退出,当时是使用Thread.MemoryBarrier ,  VolatileRead 解决  如何实现的?
            
             
  volatile关键字：1.不可以底层对代码进行优化。。。
                  2.我的read和write都是从memrory中读取。。。【我读取的都是最新的】  如何实现 的?

  class Program
    {
        public static volatile bool isStop = false;

        static void Main(string[] args)
        {
            //isStop = false;

            var t = new Thread(() =>
            {
                var isSuccess = false;

                while (!isStop)
                {
                    isSuccess = !isSuccess;
                }
            });

            t.Start();

            Thread.Sleep(1000);
            isStop = true;
            t.Join();

            Console.WriteLine("主线程执行结束！");
            Console.ReadLine();
        }
    }

Interlocked类:	为多个线程共享的变量提供原子操作。  如何理解?  如何理解非原子性操作?
《2》互锁结构： Interlocked  【只能做一些简单类型的计算】  多线程中是线程安全的,  实质上如何实现的? 
应用在什么地方? 多线程环境下自增, 多线程也就是并行,无法包装顺序
很重要的特性: 原子性操作? 
多线程与单线程有什么不同呢? 之前咋没考虑过.

    大前提就是原子性操作.   如何理解原子性? 它会用在什么地方呢?
    Increment：自增操作  
    Decrement：自减操作
    Add：      增加指定的值
    Exchange： 赋值
    CompareExchange： 比较赋值
	   
	案例:
	Interlocked.Increment(ref sum); //sum++
    Interlocked.Decrement(ref sum);//sum--
    Interlocked.Add(ref sum, 11);//sum+value
    Interlocked.Exchange(ref sum, 111);//sum=value
    Interlocked.CompareExchange(ref sum, 222, 111);//sum==111的话 ,sum=222 


SpinLock类:	提供一个相互排斥锁基元，在该基元中，尝试获取锁的线程将在重复检查的循环中等待，直至该锁变为可用为止
《3》旋转锁：SpinLock    啥是自旋?
    用到cpu指令,
    特殊的业务逻辑让thread在用户模式下进行自旋，欺骗cpu当前thread正在运行中。。。。
    
	命令如果属于用户模式的前提, 执行的时候,会传递到内核模式,来执行,执行完成后,再通过内核模式,传递给用户模式,走一个来回
	,非常消耗cpu,消耗性能,如果能留在用户模式就留在用户模式,避免通过内核模式
    用户模式 -> 内核模式 -> 用户模式 


    场景:数据递增
    

  1.啥是锁,?啥是锁机制? 概念上咋理解? 实质上在理解?  都有那些锁?
2.锁的分类: 1用户模式锁,2内核模式锁,3混合锁
3.用户模式锁
   1.易变结构, volatile关键字 =>共享变量的操作,类似同步的作用,不知道如何实现?
   2.互锁结构, interlocked,=>多线程中的共享变量的原子操作
   3.旋转锁, 
4.多线程到底有什么不一样? 锁为什么要用? 锁要达到什么目的?共享变量啥意思?啥作用?
原子性操作?锁基元啥意思? 共享机制是啥意思?   


  
  
理解的标准:理解了就不难,关键怎样算理解了? 如何去理解呢? 这样理解的程度好不? 看着整体逻辑图,清清楚楚知道过程细节?
掌握的方法:有逻辑的分析,有逻辑的理解.
掌握的标准:是否心中有概念?什么是心中有概念? 前因后果,有逻辑的推演整个过程.
掌握的技巧: 1.不要太关注,难或易,不然就陷入被动了,任何事都要主动.(想到任何事的相应的主动状态.)
           2.遇到新知识，大量不懂的概念？怎么办？ =》存在浏览式，完成任务？为什么呢？不懂的心理 驱使快速完成来安慰自己。
		   3.遇到理解卡壳，怎么办？
		   4.遇到不知所措，怎么办？
		   5.遇到错误了,该怎么办?
		   6.遇到没效率的时候,该怎么办?
		   5.关注负面的东西,着眼于美好的东西.
		   6.不关注坏习惯,而是养成好习惯,关注点要正确?
是否复习：