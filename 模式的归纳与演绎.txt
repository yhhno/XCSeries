0.学习是有目的的,选择是有帮助的.  



1.有些基础是贯穿始终的

2.基础功能,特性, 用途:


认识:为了用而学,不是为了学而学.
心态：积极的心态,拒绝不劳而获,
状态：有逻辑，有脑子，有对比，归纳，演绎，有效率，有好奇,有猜想+预期=>现状对比,拒绝想当然
经验： 1.处理问题了，不能懵逼，不能躲避，积极地，有逻辑的，有技巧的，去分析。
	   2。拒绝浅尝辄止,再进一步，很多障，如果再深入推理下，就不是问题了。如：内存爆掉
	   3.不论在学习，听讲，观察等，都不能仅仅片面的接收。=>拒绝想当然+无逻辑推理
	   3.0 逻辑推理是,从开始,到过程,到结束. 问题: 以前就是推一步,或者仅仅止步于理解当前所接受的.
	   3.1 全过程式学习,推理.认识(场景,知识点,概念)都是片面的认识,想当然的懂就可以了,必须全过程式
						   eg.学习了缓存知识点(可能还仅仅是浏览式学习),就此打住
							   学是为了用,为什么不继续学习如何使用?
							   例如自动过期,过期时间等,是使用过程的总结? 
							   以后遇到自动过期等概念,照样懵逼
							   这就是看到什么学什么, 差评
							   必须是全过程式.
	   4.学习的过程中，根据特性，就可以估计出大概的用途。 毕竟特性是拿来用的
	   5.观察,可以从局部,整体,更高层次,或者某个角度(性能)去理解.
	   6.有些基本概念是要在心中的,高时间复杂度,易丢失,
	   7.没有不劳而获,付出时间+精力+只会+技巧+积累=>结果
	   8.我们不能局限于一种语言,一种实现.....精通一种.必须要能理解另一种?  一种抽象,多种实现?
	   8.0原理有时和实现不太一样，因为有时实现的封装程度不一样， 但该做的都做了，只是在封装内部，看不到。
	   9.认识一个新知识.要从恰当的模型去认识
	   9.0 咱可以理解它是做什么的,可以怎么操作,达到什么样的目的. 这样就在使用层次上,了然于胸.   
	              然后再从源码层级去了解  首先是个集合,存,取,查, 但能满足一些特定化需要(可能不止一步,多步组合),不仅仅是根据下标获取,先进先出,先进后出,查询效率高,
				  之前问题:一看到懵逼了.浏览下就完了.
		9.1 优先级队列: 每一步都会卡壳,停止不前,此时给一个详细案例.
		                首先优先级队列是一个结果,一堆数据,可以按照优先级高低出列.
		                 然后再分析怎样实现这个特性呢 或者组合起来实现这个特性
						 数据是什么样的? 如何表示优先级?如何存储的? 
						 怎样的封装方法?实现最高级出列?,						
						 如何实现优先级队列?
								优先级队列：
											1. 先获取最大值：
											2. 删除最大值
						 到这里有点要停止的意思.相当然完成了任务
						 没有的,要继续,
						 如何继续第二高数据出列.
						 要逐步逻辑地推理下去,
						 直到达到结束条件
						 ?队列的数据容量是否不变,数据如何初始化,结束后如何处理?
						 
		10.为什么你去请教别人的时候,得到的东西最深刻? 去浏览的时候,最没印象=>这也就是为什么要猜想,要对比.
		11.一种抽象,多种实现? 我们发现请教人很有效果, 但一定非要请教人不可吗? 换一种同样抽象的实现嘛.
		11.1 自己学和跟着别人学是不同情况的,不同情况,心态,做法都是不一样的.一定要区分.
		11.2  最终是要总结出一个模型出来,用于自学的目的, 一定要多思考,多借鉴.多学习套路.
		12.不能想到组合,只想一下子就找到解决方法, 是不是唾手可得的心态.
		13.思维的惯性错误,对一个问题,习惯希望用一个东西给处理了,如果处理不了,就会心中产生沮丧.或者止步于此,然后心情沮丧,最后放弃.也算是唾手而得的心理吧.
		13.0 Sort函数,模仿sql功能. 其实也就是对sort by pattens 中的patten不了解.
		                 (此时是个一篇空白,跟着别人学习.与自学是两种情况,要区分情况)
		14.当有种不知道怎么办时?完全想不到一点线索时 怎么办?
		15.以前错误的思考方式,如何模式匹配, 正则不会, 算了,不看了.  =》屏蔽不好的东西. 局部很好呀,但用了全面.
					这是一个问题?
					1.思考方式有问题,一开始就到了最内部的地方,跳跃太大,
					2.应该认识从最高级开始,依次中级,然后最基本..
					3.有时只进行到中级就可以基本理解了.
					4.有时系统,或者产品,封装了很多的东西,作为它的最基本, 给我们使用.
		16.为什么没有发现类似目前一对一，但需要一对多的呢？以及发现一些弊端（如长连接的弊端）	
		17.思维固化: 程序都是三层? 三层方法都一样的?  错误的思维。 
                                   此例中,完全不知道数据初始化什么概念? 也不知道应用场景
								   是特性不了解?还是应用场景不知道? 还是不知道流程?
		18.通过全过程的分析,推理. 就可以破掉以前养成的错误的认识,思维.(此时提全过程, 必须只有一个主线,不能杂乱无章,至于主线,可以在修正, 但无论何时都只能有一个主线.类似一心干一件事.)
		19,拒绝浏览式的认识,一大堆浏览式的认识,就是一个大写的懵逼.
					eg:一次400w全部提交过去.
								为啥没有想到会网络卡死 +  超时? 
								可能是一大堆浏览式的认识.而不是有血有肉,环肥燕瘦的认识. 
		20.如何理清需求,然后抽象出需求流程,然后用程序来实现具体的流程? 特性与现实的映射,过时了
       	
	   
0.学习是有目的的,选择是有帮助的.  
redis 共享,新特性,更高性能

1.有些基础是贯穿始终的
redis 基于内存 共享  高性能

2.基础功能,特性, 用途:
用途:used as a database, cache and message broker
基础: 数据结构:strings, hashes, lists, sets, sorted sets 
特性:lua脚本,master-slave 哨兵,集群

3.如何才能算是达成目标:
准备：术语+场景（集群，高可用等）+底层实现的基本原理+概念(如轮询,一秒轮询一次)
标准: 有逻辑地,前因后果地,举一反三地,融会贯通地,深入本质的,有标准的,有大局观的,有优缺点的,结合实际需求的,去学习
目的: 运用手中的武器,去解决各种问题

4.学习步骤：
1，安装+官网文档
2，熟悉提供的各种功能和特性，以及每个版本的迭代更新。
3，默认启动+自定义启动定制，配置文件的熟悉。
4，按照官网文档，逐个去学习，去理解，最后去运用（对的场景）。学习的过程中，根据特性，就可以估计出大概的用途。 
功能使用溜了，就要考虑它是如何实现的？只有深入本质，才能更好的理解，更好的使用，和借鉴。
5.看源码,先整体,在局部,重点关键实现(如字符串如何表示其他类型.)
RedisServer ->redisdb[]  -> redis[0] -> dict -> key:   redisObject   就看是不是没有思考,就接受了.  逻辑思考.
				                                value: redisObject  -> ptr -> sds -> char[] -> store content
6.每个数据机构的,概念,命令,特性,都深入本质的了解,如何实现, 有用途的去契合.
6.0案例:对于bitarray,bit运算的表示和用途,没有概念?  这个问题要引申思考? 概念?脉络+前因后果?
7.位运算在不同的语言中都有实现?===>so.我们不能局限于一种语言,一种实现.....精通一种.必须要能理解另一种?  一种抽象,多种实现?
8.JAVA,C# 【Array】形式来实现的。。。 来实现的.=>说明此处有封装 =>小小的推理一下的结果
9.新东西,如何去理解? 咱可以理解它是做什么的,可以怎么操作,达到什么样的目的. 这样就在使用层次上,了然于胸.   然后再从源码层级去了解  首先是个集合,存,取,查, 但能满足一些特定化需要(可能不止一步,多步组合),不仅仅是根据下标获取,先进先出,先进后出,查询效率高,
10.




5.考虑角度:
性能:网络传输,存储,时间复杂度,
































