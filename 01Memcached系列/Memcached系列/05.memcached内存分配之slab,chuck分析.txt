
一：memcache的内存分配

1. c或者c++中，我们自己申请，自己释放。。。{低级语言,自己分配,自己释放}

2. C#/java, 我们也是在堆上或者在栈上分配，由clr或者jvm来释放。。。 【虚拟机，gc,相当于智能的程序去释放】

  这样的话，容易产生内存碎片。{高级语言中,程序员分配,  虚拟机或者gc 来释放}


二：memcache不采用随时分配，随时释放这种机制。

1. slabclass  表示某一种chuck size大小的slab。

              slabclass=slab 是一对一的关系吗？？？？

	      slabclass = slab 是一对多的关系。

2. slab  【page:相当于操作系统中页的概念】 默认是1M 【从操作系统中一次申请1M的数据】
          
          memcache会预先生成很多的内存块 [多个slabclass,也就是更多个slab]，比如有96byte，120byte，150byte。。。200byte，800byte。。。

          《1》预先生成一批slab的好处是什么？？？ 可以根据item的大小，放到合适的slab上面去。

3. chuck  memcache会将申请的1M数据分成很多的chuck。。。。  [槽位]

          【1】 到底多少个呢？？？                        1M / chuck.size == chuck.length;

          【2】 上面的这个公式如果不能整除怎么办？？？    不可避免资源浪费。

           这样的方便管理，必然会带来资源浪费。 方便的同时,必然有代价

4. item    就是我们的value数据。它是放到chuck里面。

           如果直接放置的话，必然还要带来一个问题，那就是资源浪费。
           如果我们的chuck=96b，而item=90b的话，那么就会有6b的浪费。

5.LRU链表：最近最少访问原则，slabclass是一个item的链。 item和“向前”和“向后”的指针。
            
6.hash表： 我们听到很多人说memcache就是一个巨大的hash表。 

所以严格的说，应该是一个hash+lru链表。

操作系统中有一个 “页”的概念。


1.什么是内存分配? 为什么要学习? 各个语言中是如何处理的?
2.内存非配有哪些?  自己申请,自己释放?随时分配,随时释放?  自己分配, CLR释放? 有什么坏处呢? 两种容易产生内存碎片? 后者好些?
3.memcached不采用随时分配随时释放的机制. 有自己的处理机制? 采用自己的内存分配机制 进行分配? 是什么样的分配机制呢?
4. memcached的分配机制是什么? 相关概念又是什么意思呢? slabclass slab  chuck  item 都是什么意思? 如何理解?
5.如何理解操作系统中的"页"的概念? 申请内存先申请一块?此时的一块,指一"页"内存?
6.如何理解数据库中的"数据页"概念?


未知part
1.内存分配? 操作系统的内存分配? C#的内存分配? 数据库的"数据页"? 操作系统?